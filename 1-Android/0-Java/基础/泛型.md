> version：2021/10/23
>
> review：



目录

[TOC]



### 一、泛型简介

##### 1、引入泛型的目的

要了解引入泛型的动机，可以先了解下语法糖。 

> 语法糖（Syntactic Sugar）是由英国计算机学家Peter.J.Landin发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。**Java中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类**等。虚拟机并不支持这些语法，它们**在编译阶段就被还原回了简单的基础语法结构**，这个过程成为解语法糖。

泛型的目的： 

Java 泛型就是一种语法糖，通过泛型使得在编译阶段完成一些类型转换的工作，避免在运行时强制类型转换而出现 ClassCastException ，即类型转换异常。

##### 2、泛型初探

从 JDK 1.5 开始增加了泛型，并在很大程度上都是方便集合的使用，使其能够记住其元素的数据类型。 

在泛型（Generic type或Generics）出现之前，是这么写代码的： 

```java
public static void main(String[] args) { 
	List list = new ArrayList(); 
	list.add("123"); 
	list.add("456"); 
	System.out.println((String)list.get(0)); 
} 
```

当然这是完全允许的，因为List里面的内容是Object类型的，自然任何对象类型都可以放入、都可以取出，但是这么写会有两个问题： 

1、当一个对象放入集合时，集合不会记住此对象的类型，当再次从集合中取出此对象时，该对象的编译类型变成了Object。

2、运行时需要人为地强制转换类型到具体目标，实际的程序绝不会这么简单，一个不小心就会出现java.lang.ClassCastException。 

所以，泛型出现之后，上面的代码就改成了大家都熟知的写法：

```java
public static void main(String[] args) { 
	List<String> list = new ArrayList<String>(); 
	list.add("123"); 
	list.add("456"); 
	System.out.println(list.get(0)); 
}
```

这就是泛型。泛型是对Java语言类型系统的一种扩展，有点类似于C++的模板，可以把类型参数看作是使用参数化类型时指定的类型的一个占位符。引入泛型，是对Java语言一个较大的功能增强，带来了很多的好处。

##### 3、泛型的好处

①类型安全。类型错误现在在编译期间就被捕获到了，而不是在运行时当作java.lang.ClassCastException展示出来，将类型检查从运行时挪到编译时有助于开发者更容易找到错误，并提高程序的可靠性。 

②消除了代码中许多的强制类型转换，增强了代码的可读性。 

③为较大的优化带来了可能。 

### 二、泛型的使用

#### 1、泛型类和泛型接口

下面是JDK 1.5 以后，List接口，以及ArrayList类的代码片段。

```java
// 定义接口时指定了一个类型形参，该形参名为E 
public interface List<E> extends Collection<E> { 
    // 在该接口里，E可以作为类型使用 
    public E get(int index) {} 
    public void add(E e) {} 
}

// 定义类时指定了一个类型形参，该形参名为E 
public class ArrayList<E> extends AbstractList<E> implements List <E> {
    // 在该类里，E可以作为类型使用 
    public void set(E e) { 
        ....................... 
    } 
}
```

这就是泛型的实质：允许在定义接口、类时声明类型形参，类型形参在整个接口、 类体内可当成类型使用，几乎所有可使用普通类型的地方都可以使用这种类型形参。

下面具体讲解泛型类的使用。泛型接口的使用与泛型类几乎相同，可以比对自行学习。

##### 泛型类

定义一个容器类，存放键值对key-value，键值对的类型不确定，可以使用泛型来定义，分别指定为K和V。

```java
public class Container<K, V> { 
    private K key; 
    private V value; 
    
    public Container(K k, V v) { 
        key = k; 
        value = v; 
    }
    
    public K getkey() {
        return key; 
    }
    
    public V getValue() {
        return value; 
    }
    
    public void setKey() {
        this.key = key; 
    }
    
    public void setValue() { 
        this.value = value; 
    }
}
```

在使用Container类时，只需要指定K，V的具体类型即可，从而创建出逻辑上不同的Container实例，用来存放不同的数据类型。

```java
public static void main(String[] args) { 
    Container<String,String> c1 = new Container<String ,String>( "name","hello"); 
    Container<String,Integer> c2 = new Container<String,Integer>("age",22); 			Container<Double,Double> c3 = new Container<Double,Double>(1 .1,1.3); 
    System.out.println(c1.getKey() + " : " + c1.getValue()); 
    System.out.println(c2.getKey() + " : " + c2.getValue()); 
    System.out.println(c3.getKey() + " : " + c3.getValue()); 
}
```

在JDK 1.7 增加了泛型的“菱形”语法：Java允许在构造器后不需要带完整的泛型信息，只要给出一对尖括号（**<>**）即可，Java可以推断尖括号里应该是什么泛型信息。

如下所示： 

```java
Container<String,String> c1 = new Container<>("name","hello"); Container<String,Integer> c2 = new Container<>("age",22);
```

##### 泛型类派生子类

当创建了带泛型声明的接口、父类之后，可以为该接口创建实现类，或者从该父类派生子类，需要注意：使用这些接口、父类派生子类时不能再包含类型形参，需要传入具体的类型。

 错误的方式： 

```java
public class A extends Container<K, V>{}
```

正确的方式： 

```java
public class A extends Container<Integer, String>{}
```

也可以不指定具体的类型，如下：

```java
public class A extends Container{}
```

此时系统会把K,V形参当成Object类型处理。 

#### 2、泛型的方法

前面在介绍泛型类和泛型接口中提到，可以在泛型类、泛型接口的方法中，把泛型中声明的类型形参当成普通类型使用。 如下面的方式： 

```java
public class Container<K, V> {
........................ 
    public K getkey() { 
    	return key; 
	}
    
    public void setKey() { 
        this.key = key; 
    } 
.................... 
}	
```

但在另外一些情况下，在类、接口中没有使用泛型时，定义方法时想定义类型形参，就会使用泛型方法。如下方式： 

```java
public class Main{ 
    public static <T> void out(T t){ 
        System.out.println(t); 
    }
    public static void main(String[] args){ 
        out("hansheng"); 
        out(123); 
    } 
}
```

所谓泛型方法，就是在声明方法时定义一个或多个类型形参。 泛型方法的用法格式如下： 

```java
修饰符<T, S> 返回值类型 方法名（形参列表）｛ 
    方法体 
｝
```

注意： 方法声明中定义的形参只能在该方法里使用，而接口、类声明中定义的类型形参则可以在整个接口、类中使用。 

```java
class Demo{ 
    public <T> T fun(T t){ // 可以接收任意类型的数据 
        return t ; // 直接把参数返回 
    } 
};
public class GenericsDemo26{ 
    public static void main(String args[]){ 
        Demo d = new Demo() ; // 实例化Demo对象 
        String str = d.fun("汤姆") ; // 传递字符串 
        int i = d.fun(30) ; // 传递数字，自动装箱 
        System.out.println(str) ; // 输出内容 
        System.out.println(i) ; // 输出内容 
    } 
};
```

当调用 fun() 方法时，根据传入的实际对象，编译器就会判断出类型形参T所代表的实际类型。

#### 3、泛型构造器

正如泛型方法允许在方法签名中声明类型形参一样，Java也允许在构造器签名中声明类型形参，这样就产生了所谓的泛型构造器。 

和使用普通泛型方法一样没区别，一种是显式指定泛型参数，另一种是隐式推断， 如果是显式指定则以显式指定的类型参数为准，如果传入的参数的类型和指定的类型实参不符，将会编译报错。 

```java
public class Person { 
    public <T> Person(T t) { 
        System.out.println(t); 
    } 
}

public static void main(String[] args){ 
    // 隐式 
    new Person(22); 
    // 显式
    new<String> Person("hello"); 
}
```

这里唯一需要特殊注明的就是，如果构造器是泛型构造器，同时该类也是一个泛型类的情况下应该如何使用泛型构造器：因为泛型构造器可以显式指定自己的类型参数（需要用到菱形，放在构造器之前），而泛型类自己的类型实参也需要指定（菱形放在构造器之后），这就同时出现了两个菱形了，这就会有一些小问题，具体用法再这里总结一下。 

以下面这个例子为代表

```java
public class Person<E> { 
    public <T> Person(T t) { 
        System.out.println(t); 
    } 
}
```

这种用法： Person<String> a = new <Integer>Person<>(15); 这种语法不允 许，会直接编译报错！

### 三、类型通配符



### 四、类型擦除





# 相关问题

<font color='orange'>Q：说一下泛型原理，并举例说明</font>

创建集合的时候，往集合里面添加数据，再次取出时，集合会忘记这数据类型，该对象的编译类型就会变成Object类型，否则如果想要变回原来的数据类型的时候，就要强制进行转换。创建集合的时候，我们就指定集合类型，避免这个过程。 

<font color='orange'>Q：通配符是什么？</font>

通配符使用 ？表示，可以代表任意参数类型。

使用通配符时，可以使用 extends 或者 super 为其添加限制。

extends 表示泛型的上限，super表示泛型的下限。

<font color='orange'>Q：什么是泛型擦除？</font>

泛型是用来辅助程序员开发的，在编译阶段会被转换为原始的类，类型参数都会被删除，专业术语就叫“类型擦除”。擦除后的类型如果没有界限的话，会变成Object类，如果有的话，会变成最顶级的父类类型。

<font color='orange'>Q：泛型的特点与优缺点？</font>

优点:

1、类型安全，使用泛型可以避免类型转换错误，在使用的时候，如果传入不同的类型，在编译阶段会报错

2、最大限度地重用代码，所有转换都是自动和隐式的。

3、提高性能，因为值类型可以避免装箱和拆箱所带来的损耗(垃圾回收的次数也会减少)。

缺点：



> 这个问题还不是很清楚。

<font color='orange'>Q：泛型中<?superT>和<?extendsT>的区别。</font>

<? extends T>限定参数类型的上界，参数类型必须是T或T的子类型，但对于List<? extends T>，不能通过add()来加入元素，因为不知道<? extends T>是T的哪一种子类；

<? super T>限定参数类型的下界，参数类型必须是T或T的父类型，不能能过get()获取元素，因为不知道哪个超类；





# 目录

- 定义
- 意义（即为什么要使用泛型）
- 作用及特点
- 原理
- 额外说明： List<String>能否转为List<Object>？

------

# 定义

可理解为 适配广泛的类型，即参数化类型，可以把类型像方法的参数那样进行传递。



```cpp
// 以ArrayList为示例
// 泛型T可以是任意类
public class ArrayList<T> {
    private T[] array;
    //...
}

// 通过泛型的使用，就可创建多种类型的ArrayList
// 1. 可存储String的ArrayList:
ArrayList<String> strList = new ArrayList<String>();
// 相当于
public class ArrayList<String> {
    private String[] array;
    //...
}

// 2. 可存储Float的ArrayList:
ArrayList<Float> floatList = new ArrayList<Float>();
// 相当于
public class ArrayList<Float> {
    private Float[] array;
    //...
}
```

------

# 意义（即为什么要使用泛型）

**通过定义一种模板方式结构，从而保证类型安全 & 匹配**。下面将用ArrayList为示例作为说明。

## 1. 背景

ArrayList的本质：一个可变的Object类型数组



```cpp
public class ArrayList {
    private Object[] array;
    // ...
}
```

## 2. 问题

在使用ArrayList存储不同类型时，需要强转类型，不然容易出现ClassCastException异常。如存储String类型：



```cpp
// 获取到ArrayList里的Object类型时，必须强制转型为String
// 不然容易出现ClassCastException异常
ArrayList list = new ArrayList();
list.add("carson ho");
String first = (String) list.get(0);
```

## 3. 解决方案

使用泛型将ArrayList变成一种模板：ArrayList<T>，就可以创建任意类型的ArrayList。即：



```cpp
// 泛型T可以是任意类
public class ArrayList<T> {
    private T[] array;
    //...
}

// 多种类型
// 1. 可存储String的ArrayList:
ArrayList<String> strList = new ArrayList<String>();
// 相当于
public class ArrayList<String> {
    private String[] array;
    //...
}

// 2. 可存储Float的ArrayList:
ArrayList<Float> floatList = new ArrayList<Float>();
// 相当于
public class ArrayList<Float> {
    private Float[] array;
    //...
}
```

------

# 作用

1. 使编译器可在编译期间对类型进行检查以提高类型安全，减少运行时由于对象类型不匹配引发的异常；
2. 运行时所有的转换都是强制、隐式的，大大提高了代码的重用率。如对集合类取数据时，不需 对存储的数据 进行强制类型转换。

------

# 原理

**基于 类型擦除**。即即 使用泛型时加上的类型参数，会在编译器在编译时去掉所以，在生成的 Java 字节码中，不包含泛型中的类型信息。这里需要特别说明的是：

- Java中的泛型是在编译器层次实现，编译器在编译时尽可能的发现可能出错的地方，但仍无法避免在运行时刻出现类型转换异常的情况；
- 在代码中定义的List<object> 、List<String>等类型，在编译后都会变成List
- JVM看到的只是List，而由泛型附加的类型信息对JVM来说是不可见的

同时需要特别注意的是：

- 在无泛型的情况下，通常是使用Object类型来进行多种类型数据的操作，此时操作最多的是针对该Object进行数据的强制转换
- 而这种转换是基于开发者对该数据类型明确的情况下进行（如将Object型转换为String型）；若类型不一致，编译器在编译过程中不会报错，但在运行时会出错

------

# 额外说明： List<String>能否转为List<Object>？

不能。具体描述如下：

![img](https:////upload-images.jianshu.io/upload_images/944365-b001acf2eeafbecc.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

示意图



```dart
// 代码1和代码2相同
// 代码1
List<String> strings = new LinkedList<String>( ); 
 List<Integer> ints = new LinkedList<Integer>( );

// 代码2
 List strings = new LinkedList( ); 
 List ints = new LinkedList( );

// 转换方式可以是如下：
List ss=strings; 
List<Object> objects=ss;
```

至此，关于Java中的泛型讲解完毕。



# 参考

[Carson带你学Java：泛型知识知多少](https://www.jianshu.com/p/7f42e090c8a2)
