

# 引用类型

`WeakReference` 是 Java 中的一个类，它属于 Java 的引用类型之一。在 Java 中，有四种类型的引用：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）。这些不同类型的引用提供了对对象生命周期的精细控制。



## Reference

#### get

获取引用所持有的对象。

对于 WeakReference 两种情况返回null，持有对象被 gc 回收后、主动调用clear后。

#### clear

调用此方法后，引用将不再指向对象，get 方法将返回 null。

如果使用了 ReferenceQueue，主动调用 clear，ReferenceQueue 中不会添加 Reference；并且在后续 gc 回收之前引用的对象后，也不会再将 Reference 添加到队列中。

```kotlin
    public void clear() {
        clearReferent();
    }
```

# WeakReference

`WeakReference` 类表示一个对对象的弱引用，这意味着它不会阻止其引用的对象被垃圾回收器回收。当垃圾回收器决定回收某个对象时，即使该对象仍被 `WeakReference` 引用，它也会被回收。因此，`WeakReference` 主要用于实现缓存等需要对象能被适时回收的场景。

使用 `WeakReference` 的一个常见场景是缓存大型对象，例如图像或文件。由于 `WeakReference` 不会阻止垃圾回收，因此当内存紧张时，这些对象可以被回收，从而避免内存溢出。

下面是一个简单的 `WeakReference` 使用示例：

示例1：

```kotlin
import java.lang.ref.WeakReference;  
  
public class WeakReferenceExample {  
    private static class LargeObject {  
        // 模拟一个大对象  
        private byte[] data = new byte[1024 * 1024]; // 1MB  
    }
  
    public static void main(String[] args) {  
        LargeObject largeObject = new LargeObject();  
        WeakReference<LargeObject> weakRef = new WeakReference<>(largeObject);  
  
        // 此时 largeObject 仍然有一个强引用，因此不会被回收  
        System.out.println(weakRef.get()); // 输出: LargeObject@xxxxxxx  
  
        largeObject = null; // 移除强引用  
        System.gc(); // 尝试触发垃圾回收（注意：这只是一个建议，不保证一定会执行）  
  
        // 等待一段时间，让垃圾回收器有机会运行  
        try {  
            Thread.sleep(1000);  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        }  
  
        // 由于 largeObject 的强引用已经被移除，垃圾回收器可能已经回收了它  
        // 因此，weakRef.get() 可能会返回 null  
        System.out.println(weakRef.get()); // 输出: null 或 LargeObject@xxxxxxx（取决于垃圾回收是否执行）  
    }  
}
```

示例2：

下面是 WeakReference 的另一个构造函数：

```java
public WeakReference(T referent, ReferenceQueue<? super T> q) {  
    super(referent, q);  
}
```

- `T referent`：想要创建弱引用的对象。
- `ReferenceQueue<? super T> q`：一个可选的引用队列，用于存储那些已经被垃圾收集器回收的弱引用对象。

### ReferenceQueue 的作用

`ReferenceQueue` 是一个队列，用于保存那些已经被垃圾收集器确定为不再被引用的对象所对应的引用。当一个对象仅被弱引用所引用，并且该对象被垃圾收集器回收时，相应的弱引用对象会被添加到与之关联的 `ReferenceQueue` 中（如果提供了的话）。这样，可以通过检查这个队列来得知哪些弱引用已经变得无效。

### 为什么要使用 ReferenceQueue？

使用 `ReferenceQueue` 的一个主要原因是能够得知弱引用何时变得无效，这在需要执行一些清理工作或跟踪引用何时被 GC 时非常有用。例如，可能想要知道缓存中的哪些条目已经不再被使用，从而可以安全地从缓存中移除它们。

### 使用示例

下面是一个简单的示例，展示了如何使用 `WeakReference` 和 `ReferenceQueue`：

```java
import java.lang.ref.WeakReference;  
import java.lang.ref.ReferenceQueue;  
  
public class WeakReferenceExample {  
    public static void main(String[] args) throws InterruptedException {  
        Object strongRef = new Object();  
        ReferenceQueue<Object> queue = new ReferenceQueue<>();  
        WeakReference<Object> weakRef = new WeakReference<>(strongRef, queue);  
  
        System.out.println("Initial weakRef: " + weakRef.get());  
  
        strongRef = null; // 移除强引用  
  
        // 强制进行垃圾收集（通常不建议在生产代码中使用）  
        System.gc();  
        Thread.sleep(100); // 等待垃圾收集器运行  
  
        // 检查 ReferenceQueue 中是否有新的引用  
        Reference<? extends Object> ref = queue.poll();  
        if (ref != null) {  
            System.out.println("Reference in queue: " + ref);  
        } else {  
            System.out.println("No reference in queue.");  
        }  
  
        // 再次尝试获取弱引用指向的对象  
        System.out.println("After GC, weakRef: " + weakRef.get());  
    }  
}
```

在这个例子中，我们创建了一个 `WeakReference`，并传递了一个 `ReferenceQueue`。当强引用被置为 `null` 并且垃圾收集器回收了对象后，我们通过调用 `queue.poll()` 来检查 `ReferenceQueue` 中是否有新的引用。如果有，这意味着我们的弱引用对象已经不再指向一个有效的对象了。



使用场景：







**参考：**

1、

