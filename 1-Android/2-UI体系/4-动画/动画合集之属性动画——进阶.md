> version：2022/10/7
>
> review：



# Android：属性动画核心使用-ValueAnimator类学习指南

# 前言

- 属性动画的使用 是 `Android` 开发中常用的知识
- 今天，我将讲解属性动画使用中最核心的一个方法类：`ValueAnimator`，希望你们会喜欢

# 目录

![img](https:////upload-images.jianshu.io/upload_images/944365-84edf9b834546621.png?imageMogr2/auto-orient/strip|imageView2/2/w/1082/format/webp)

示意图

# 1. 简介

属性动画机制中 最核心的一个类

------

# 2. 原理

- 通过不断控制 值 的变化，再不断 手动 赋给对象的属性，从而实现动画效果。
- 具体如图下：

![img](https:////upload-images.jianshu.io/upload_images/944365-e92b5c3efabbeb42.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

示意图

从上面原理可以看出：`ValueAnimator`类中有3个重要方法：

1. `ValueAnimator.ofInt（int values）`
2. `ValueAnimator.ofFloat（float values）`
3. `ValueAnimator.ofObject（int values）`

下面我将逐一介绍。

------

# 3. 整型：ValueAnimator.ofInt（）

### 3.1 作用

将初始值 **以整型数值的形式** 过渡到结束值

> 即估值器是整型估值器 - `IntEvaluator`

### 3.2 工作原理

![img](https:////upload-images.jianshu.io/upload_images/944365-59dc8a7bd432a0fc.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

示意图

### 3.3 具体使用

- 因为ValueAnimator本质只是一种值的操作机制，所以下面的介绍先是展示如何改变一个值的过程（下面的实例主要讲解：如何将一个值从0平滑地过渡到3）
- 至于如何实现动画，是需要开发者手动将这些 值 赋给 对象的属性值。关于这部分在下节会进行说明。

操作值的方式 分为 `XML` 设置 / `Java` 代码设置，具体如下：



```java
/*
 * 设置方式1：xml
 */
// 步骤1：在路径 res/animator的文件夹里创建相应的动画 .xml文件 - set_animation.xml

// 步骤2：设置动画参数
// ValueAnimator采用<animator>  标签
<animator xmlns:android="http://schemas.android.com/apk/res/android"  
    android:valueFrom="0"   // 初始值
    android:valueTo="3"  // 结束值
    android:valueType="intType" // 变化值类型 ：floatType & intType

    android:duration="3000" // 动画持续时间（ms），必须设置，动画才有效果
    android:startOffset ="1000" // 动画延迟开始时间（ms）
    android:fillBefore = “true” // 动画播放完后，视图是否会停留在动画开始的状态，默认为true
    android:fillAfter = “false” // 动画播放完后，视图是否会停留在动画结束的状态，优先于fillBefore值，默认为false
    android:fillEnabled= “true” // 是否应用fillBefore值，对fillAfter值无影响，默认为true
    android:repeatMode= “restart” // 选择重复播放动画模式，restart代表正序重放，reverse代表倒序回放，默认为restart|
    android:repeatCount = “0” // 重放次数（所以动画的播放次数=重放次数+1），为infinite时无限重复
    android:interpolator = @[package:]anim/interpolator_resource // 插值器，即影响动画的播放速度,下面会详细讲
/> 

// 步骤3：启动动画
    // 载入XML动画
    Animator animator = AnimatorInflater.loadAnimator(context, R.animator.set_animation);  
    // 设置动画对象
    animator.setTarget(view);  
    // 启动动画
    animator.start();  

/*
 * 设置方式2：Java
 */
// 步骤1：设置动画属性的初始值 & 结束值
    ValueAnimator anim = ValueAnimator.ofInt(0, 3);
    // ofInt()作用：
    // 1. 创建动画实例
    // 2. 将传入的多个Int参数进行平滑过渡:此处传入0和3,表示将值从0平滑过渡到3
    // 如果传入了3个Int参数 a,b,c ,则是先从a平滑过渡到b,再从b平滑过渡到C，以此类推
    // ValueAnimator.ofInt()内置了整型估值器,直接采用默认的.不需要设置，即默认设置了如何从初始值 过渡到 结束值
    // 关于自定义插值器我将在下节进行讲解
    // 下面看看ofInt()的源码分析 ->>关注1

    // 关注1：ofInt（）源码分析
    public static ValueAnimator ofInt(int... values) {
    // 允许传入一个或多个Int参数
    // 1. 输入一个的情况（如a）：从0过渡到a；
    // 2. 输入多个的情况（如a，b，c）：先从a平滑过渡到b，再从b平滑过渡到C

    ValueAnimator anim = new ValueAnimator();
    // 创建动画对象
    anim.setIntValues(values);
    // 将传入的值赋值给动画对象
    return anim;
}

// 步骤2：设置动画的播放各种属性
    // 设置动画运行的时长
    anim.setDuration(500); 
    
    // 设置动画延迟播放时间
    anim.setStartDelay(500); 

    // 设置动画重复播放次数 = 重放次数+1
    // 动画播放次数 = infinite时,动画无限重复
    anim.setRepeatCount(0);
    
    // 设置重复播放动画模式
    anim.setRepeatMode(ValueAnimator.RESTART);
    // ValueAnimator.RESTART(默认):正序重放
    // ValueAnimator.REVERSE:倒序回放

// 步骤3：将改变的值手动赋值给对象的属性值：通过动画的更新监听器
// 设置值的更新监听器，即：值每次改变、变化一次,该方法就会被调用一次
    anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
        @Override
        public void onAnimationUpdate(ValueAnimator animation) {

        // 获得改变后的值
        int currentValue = (Integer) animation.getAnimatedValue();

        // 将改变后的值赋给对象的属性值，下面会详细说明
        View.setproperty（currentValue）；

        // 刷新视图，即重新绘制，从而实现动画效果
        View.requestLayout();
             }
        });

// 步骤4：启动动画
  anim.start();
```

值 从初始值 过度到 结束值 的过程如下效果图：

![img](https:////upload-images.jianshu.io/upload_images/944365-3b0aa80a2ec26e88.png?imageMogr2/auto-orient/strip|imageView2/2/w/852/format/webp)

效果图

### 3.4 实例说明

- 下面，我将结合 **手动赋值给对象属性** 这一步骤，从而实现一个完整的动画效果
- 实现的动画效果：按钮的宽度从 `150px` 放大到 `500px`

![img](https:////upload-images.jianshu.io/upload_images/944365-cf61973c2bcbc9ee.gif?imageMogr2/auto-orient/strip|imageView2/2/w/386/format/webp)

效果图



```java
// 创建动画作用对象：此处以Button为例
    Button mButton = (Button) findViewById(R.id.Button);

// 步骤1：设置属性数值的初始值 & 结束值
    ValueAnimator valueAnimator = ValueAnimator.ofInt(mButton.getLayoutParams().width, 500);
    // 初始值 = 当前按钮的宽度，此处在xml文件中设置为150
    // 结束值 = 500
    // ValueAnimator.ofInt()内置了整型估值器,直接采用默认的.不需要设置
    // 即默认设置了如何从初始值150 过渡到 结束值500

// 步骤2：设置动画的播放各种属性
    // 设置动画运行时长:1s
    valueAnimator.setDuration(2000);
        

// 步骤3：将属性数值手动赋值给对象的属性:此处是将值赋给按钮的宽度
// 设置更新监听器：即数值每次变化更新都会调用该方法
    valueAnimator.addUpdateListener(new AnimatorUpdateListener() {
        @Override
        public void onAnimationUpdate(ValueAnimator animator) {

            // 获得每次变化后的属性值
            int currentValue = (Integer) animator.getAnimatedValue();
        
            // 每次值变化时，将值手动赋值给对象的属性
            // 即将每次变化后的值赋给按钮的宽度，这样就实现了按钮宽度属性的动态变化
            mButton.getLayoutParams().width = currentValue;
            

            // 步骤4：刷新视图，即重新绘制，从而实现动画效果
            mButton.requestLayout();
                
            }
        });

// 步骤4：启动动画
valueAnimator.start();
```

------

# 4. 浮点型：ValueAnimator.oFloat（）

### 4.1 作用

将初始值 以浮点型数值的形式 过渡到结束值

### 4.2 工作原理

![img](https:////upload-images.jianshu.io/upload_images/944365-d9bdedd5d6cb6238.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

示意图

### 4.3 具体使用

其使用方式跟ValueAnimator.ofInt()十分类似，此处仅展示区别之处：



```cpp
/*
 * 设置方式1：xml
 */
<animator xmlns:android="http://schemas.android.com/apk/res/android"  
    android:valueFrom="0"  
    android:valueTo="3"  
    android:valueType="floatType" // 区别：设置为浮点型类型
    ... // 其余属性设置跟ValueAnimator.ofInt类似
    />  

/*
 * 设置方式2：Java
 */
ValueAnimator anim = ValueAnimator.ofFloat(0, 3);  
// 采用ValueAnimator.ofFloat()
// 其他使用类似ValueAnimator.ofInt（int values），此处不作过多描述
```

#### 效果图

![img](https:////upload-images.jianshu.io/upload_images/944365-21ebbc2efbb1a810.png?imageMogr2/auto-orient/strip|imageView2/2/w/954/format/webp)

效果图

从上面可以看出，`ValueAnimator.ofInt（）`与`ValueAnimator.oFloat（）`仅仅只是在估值器上的区别：（即如何从初始值 过渡 到结束值）

- `ValueAnimator.oFloat（）`采用默认的浮点型估值器 (`FloatEvaluator`)
- `ValueAnimator.ofInt（）`采用默认的整型估值器（`IntEvaluator`）

在使用上完全没有区别，此处对`ValueAnimator.oFloat（）`的使用就不作过多描述。

------

# 5. 对象：ValueAnimator.ofObject（）

### 5.1 作用

将初始值 以对象的形式 过渡到结束值

> 即通过操作 对象 实现动画效果

### 5.2 工作原理

![img](https:////upload-images.jianshu.io/upload_images/944365-8e6eb4174bbbd4af.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

示意图

### 5.3 具体使用



```cpp
// 1. 创建初始动画时的对象  & 结束动画时的对象
myObject object1 = new myObject();  
myObject object2 = new myObject();  

// 2. 创建动画对象 
ValueAnimator anim = ValueAnimator.ofObject(new myObjectEvaluator(), object1, object2);  
// 参数说明
// 参数1：自定义的估值器对象(TypeEvaluator) - 下面会详细介绍
// 参数2：初始动画的对象
// 参数3：结束动画的对象

// 3. 设置参数
anim.setDuration(5000);  

// 4. 启动动画
anim.start(); 
```

在继续讲解`ValueAnimator.ofObject（）`的使用前，我先讲一下估值器（`TypeEvaluator`）

### 5.4 估值器（TypeEvaluator）

- 作用：设置动画 如何从初始值 过渡到 结束值 的逻辑

> 1. 插值器（`Interpolator`）决定 值 的变化模式（匀速、加速blabla）
> 2. 估值器（`TypeEvaluator`）决定 值 的具体变化数值

从上面可知：

- `ValueAnimator.ofFloat（）`实现了 将初始值 以浮点型的形式 过渡到结束值 的逻辑，那么这个过渡逻辑具体是怎么样的呢？
- 其实是系统内置了一个 `FloatEvaluator`估值器，内部实现了初始值与结束值 以浮点型的过渡逻辑
- 我们来看一下 `FloatEvaluator`的代码实现：



```java
// 步骤1：FloatEvaluator实现了TypeEvaluator接口
public class FloatEvaluator implements TypeEvaluator {  

// 步骤2：重写evaluate()
    public Object evaluate(float fraction, Object startValue, Object endValue) { 

        // 初始值过渡到结束值 的算法是：
        // 1. 用结束值减去初始值，算出它们之间的差值
        // 2. 用上述差值乘以fraction系数
        // 3. 再加上初始值，就得到当前动画的值
        float startFloat = ((Number) startValue).floatValue();  
        return startFloat + fraction * (((Number) endValue).floatValue() - startFloat);  
    }  
} 
```

- `ValueAnimator.ofInt（）` & `ValueAnimator.ofFloat（）`都具备系统内置的估值器，即`FloatEvaluator` & `IntEvaluator`

> 即系统已经默认实现了 **如何从初始值 过渡到 结束值 的逻辑**

- 但对于`ValueAnimator.ofObject（）`，从上面的工作原理可以看出并没有系统默认实现，因为对对象的动画操作复杂 & 多样，系统无法知道如何从初始对象过度到结束对象
- 因此，对于`ValueAnimator.ofObject（）`，我们需自定义估值器（`TypeEvaluator`）来告知系统如何进行从 初始对象 过渡到 结束对象的逻辑
- 自定义实现的逻辑如下



```java
// 步骤1：实现TypeEvaluator接口
    public class ObjectEvaluator implements TypeEvaluator{  

// 步骤2：复写evaluate()
// 作用：估值器的计算逻辑，即写入对象动画过渡的逻辑
    @Override  
    public Object evaluate(float fraction, Object startValue, Object endValue) {  
        // 参数说明
        // fraction：表示动画完成度（根据它来计算当前动画的值），也是插值器getInterpolation()的返回值
        // startValue：动画的初始值
        // endValue：动画的结束值

        // 估值器的计算逻辑
        ... 
        
        // 返回对象动画过渡逻辑计算后的值
        // 即赋给动画属性的具体数值
        return value;  
    } 
```

### 5.5 实例说明

下面我将用实例说明该如何自定义估值器并通过`ValueAnimator.ofObject()`实现动画效果：一个圆从左上角移动到右下角，如下图所示。

![img](https:////upload-images.jianshu.io/upload_images/944365-45b817bd4ca8c119.gif?imageMogr2/auto-orient/strip|imageView2/2/w/386/format/webp)

效果图

- 工程目录文件如下：

  ![img](https:////upload-images.jianshu.io/upload_images/944365-07fe96c57b90f28f.png?imageMogr2/auto-orient/strip|imageView2/2/w/313/format/webp)

  工程目录

### 步骤1：定义对象类

- 因为`ValueAnimator.ofObject（）`是面向对象操作的，所以需要自定义对象类。
- 本例需要操作的对象是 **圆的点坐标**
   *Point.java*



```cpp
public class Point {

    // 设置两个变量用于记录坐标的位置
    private float x;
    private float y;

    // 构造方法用于设置坐标
    public Point(float x, float y) {
        this.x = x;
        this.y = y;
    }

    // get方法用于获取坐标
    public float getX() {
        return x;
    }

    public float getY() {
        return y;
    }
}
```

## 步骤2：根据需求自定义估值器

- 即实现TypeEvaluator接口和复写evaluate()，其主要目的是自定义如何从初始点坐标过渡到结束点坐标；
- 本例需要实现的是一个从左上角到右下角的坐标过渡逻辑。

![img](https:////upload-images.jianshu.io/upload_images/944365-45b817bd4ca8c119.gif?imageMogr2/auto-orient/strip|imageView2/2/w/386/format/webp)

效果图



```java
// PointEvaluator.java
// 步骤1：实现TypeEvaluator接口
public class PointEvaluator implements TypeEvaluator {

    // 步骤2：复写evaluate（）
    // 作用：估值器的计算逻辑，即写入对象动画过渡的逻辑
    @Override
    public Object evaluate(float fraction, Object startValue, Object endValue) {

        // 将动画初始值startValue 和 动画结束值endValue 强制类型转换成Point对象
        Point startPoint = (Point) startValue;
        Point endPoint = (Point) endValue;

        // 根据fraction来计算当前动画的x和y的值
        float x = startPoint.getX() + fraction * (endPoint.getX() - startPoint.getX());
        float y = startPoint.getY() + fraction * (endPoint.getY() - startPoint.getY());
        
        // 将计算后的坐标封装到一个新的Point对象中并返回
        Point point = new Point(x, y);
        return point;
    }
}
```

### 步骤3：将属性动画作用到自定义View当中

即通过对Point对象进行动画操作，从而实现整个自定义View的动画效果。



```java
// MyView.java
public class MyView extends View {

    public static final float RADIUS = 70f;// 圆的半径 = 70
    private Point currentPoint;// 当前点坐标
    private Paint mPaint;// 绘图画笔

    // 初始化画笔
    public MyView(Context context, AttributeSet attrs) {
        super(context, attrs);
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        mPaint.setColor(Color.BLUE);
    }

    // 复写onDraw()从而实现绘制逻辑
    // 绘制逻辑:先在初始点画圆,通过监听当前坐标值(currentPoint)的变化,每次变化都调用onDraw()重新绘制圆,从而实现圆的平移动画效果
    @Override
    protected void onDraw(Canvas canvas) {
    // 如果当前点坐标为空(即第一次)
    if (currentPoint == null) {
        currentPoint = new Point(RADIUS, RADIUS);
        // 创建一个点对象(坐标是(70,70))

        // 在该点画一个圆:圆心 = (70,70),半径 = 70
        float x = currentPoint.getX();
        float y = currentPoint.getY();
        canvas.drawCircle(x, y, RADIUS, mPaint);

    // 重点关注
    // 将属性动画作用到View中
        // 步骤1:创建初始动画时的对象点  & 结束动画时的对象点
        Point startPoint = new Point(RADIUS, RADIUS);// 初始点为圆心(70,70)
        Point endPoint = new Point(700, 1000);// 结束点为(700,1000)

        // 步骤2:创建动画对象 & 设置初始值 和 结束值
        ValueAnimator anim = ValueAnimator.ofObject(new PointEvaluator(), startPoint, endPoint);
        // 参数说明
        // 参数1：TypeEvaluator 类型参数 - 使用自定义的PointEvaluator(实现了TypeEvaluator接口)
        // 参数2：初始动画的对象点
        // 参数3：结束动画的对象点

        // 步骤3：设置动画参数
        anim.setDuration(5000);
        // 设置动画时长

        // 步骤3：通过 值 的更新监听器，将改变的对象手动赋值给当前对象
        // 此处是将 改变后的坐标值对象 赋给 当前的坐标值对象
        // 设置 值的更新监听器
        // 即每当坐标值（Point对象）更新一次,该方法就会被调用一次
        anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
            @Override
            public void onAnimationUpdate(ValueAnimator animation) {
                currentPoint = (Point) animation.getAnimatedValue();
                // 将每次变化后的坐标值（估值器PointEvaluator中evaluate（）返回的Piont对象值）到当前坐标值对象（currentPoint）
                // 从而更新当前坐标值（currentPoint）

        // 步骤4：每次赋值后就重新绘制，从而实现动画效果
                invalidate();
                // 调用invalidate()后,就会刷新View,即才能看到重新绘制的界面,即onDraw()会被重新调用一次
                // 所以坐标值每改变一次,就会调用onDraw()一次
            }
        });

        anim.start();
        // 启动动画


    } else {
        // 如果坐标值不为0,则画圆
        // 所以坐标值每改变一次,就会调用onDraw()一次,就会画一次圆,从而实现动画效果

        // 在该点画一个圆:圆心 = (30,30),半径 = 30
        float x = currentPoint.getX();
        float y = currentPoint.getY();
        canvas.drawCircle(x, y, RADIUS, mPaint);
    }
  }
}
```

### 步骤4：在布局文件加入自定义View空间

*activity_main.xml*



```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:paddingBottom="@dimen/activity_vertical_margin"
    android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    tools:context="scut.carson_ho.valueanimator_ofobject.MainActivity">

    <scut.carson_ho.valueanimator_ofobject.MyView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
         />
</RelativeLayout>
```

### 步骤5：在主代码文件设置显示视图

*MainActivity.java*



```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }
}
```

## 效果图

![img](https:////upload-images.jianshu.io/upload_images/944365-45b817bd4ca8c119.gif?imageMogr2/auto-orient/strip|imageView2/2/w/386/format/webp)

效果图

### 源码地址

Carson_Ho的Github地址：[https://github.com/Carson-Ho/PropertyAnimator_ofObject](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FCarson-Ho%2FPropertyAnimator_ofObject)

### 特别注意

从上面可以看出，其实`ValueAnimator.ofObject（）`的本质还是操作 **值**，只是是采用将 多个值 封装到一个对象里的方式 同时对多个值一起操作而已

> 就像上面的例子，本质还是操作坐标中的x，y两个值，只是将其封装到Point对象里，方便同时操作x，y两个值而已

------

# 6. 与`ObjectAnimator`类对比

对比于属性动画中另外一个比较核心的使用类：`ObjectAnimator`类：

### 6.1 相同点

其二者的本质都是相同：不断改变值，然后不断赋值给对象的属性从而实现动画效果

### 6.2 区别

二者的区别在于：赋值给对象属性的操作是直接还是间接的。

- ValueAnimator类：不断改变值，然后手动赋值给对象的属性从而实现动画效果，是间接对对象属性进行操作；
- ObjectAnimator类：不断改变值，然后自动赋值给对象的属性从而实现动画效果，是直接对对象属性进行操作；

可以理解为：ObjectAnimator类的使用更加智能、自动化程度更高。

至此，关于属性动画中最核心的 `ValueAnimator`类已经讲解完毕。

------

# 7. 总结

- 本文对`Android` 属性动画中的最核心的 `ValueAnimator`类进行全面 & 详细介绍，下面我将继续讲解另外一个重要的类：`ObjectAnimator`类





# 前言

- 属性动画的使用 是 `Android` 开发中常用的知识
- 本文将献上一份全面 & 详细的属性动画学习指南，将详细介绍**属性动画**的所有内容，包括：意义、作用、应用场景、功原理 & 具体使用等，希望你们会喜欢。

> Carson带你学`Android`动画系列文章：
>  [Carson带你学Android：一份全面&详细的动画知识学习攻略](https://www.jianshu.com/p/53759778284a)
>  [Carson带你学Android：常见的三种动画类型](https://www.jianshu.com/p/53759778284a)
>  [Carson带你学Android：补间动画学习教程](https://www.jianshu.com/p/733532041f46)
>  [Carson带你学Android：属性动画学习教程](https://www.jianshu.com/p/2412d00a0ce4)
>  [Carson带你学Android：逐帧动画学习教程](https://www.jianshu.com/p/225fe1feba60)
>  [Carson带你学Android：自定义动画神器-估值器(含实例教学)](https://www.jianshu.com/p/ab5785f017b2)
>  [Carson带你学Android：自定义动画神器-插值器(含实例教学)](https://www.jianshu.com/p/2f19fe1e3ca1)

------

# 目录

![img](https:////upload-images.jianshu.io/upload_images/944365-683ffe3c42859b7a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1034/format/webp)

示意图

------

# 1. 出现的意义

Android一开始提供了视图动画，即补间动画跟逐帧动画。但视图动画存在三个问题：

![img](https:////upload-images.jianshu.io/upload_images/944365-2b2221763e763182.png?imageMogr2/auto-orient/strip|imageView2/2/w/540/format/webp)

为了弥补视图动画的缺陷，于是Android在3.0(API 11)开始提供了一种全新的动画模式：属性动画(Property Animation)。

------

# 2. 简介

- 作用对象：任意 `Java` 对象，即不再局限于 视图View对象
- 动画效果：可自定义各种动画效果，即不再局限于4种基本变换：平移、旋转、缩放 & 透明度

------

# 3. 特点

- 作用对象进行了扩展：不只是View对象，甚至没对象也可以
- 动画效果：不只是4种基本变换，还有其他动画效果
- 作用领域：API11后引入的

------

# 4. 工作原理

在一定时间间隔内，通过不断对值进行改变、不断将该值赋给对象的属性(任意对象的任意属性)，从而实现该对象在该属性上的动画效果。整个工作原理的流程如下：

![img](https:////upload-images.jianshu.io/upload_images/944365-9198e253d05f213c.png?imageMogr2/auto-orient/strip|imageView2/2/w/470/format/webp)

从上述工作原理可以看出属性动画中有两个非常重要的使用类：`ValueAnimator` 类 & `ObjectAnimator` 类。所以，在下面介绍属性动画的具体使用时，我会着重介绍这两个类。

------

# 5. 具体使用

对于属性动画的使用，主要是：

1. 两个使用方法类：`ValueAnimator` 类 & `ObjectAnimator` 类
2. 两个辅助使用类：插值器 & 估值器

下面将详细介绍

### 5.1 ValueAnimator类

- 定义：属性动画机制中 最核心的一个类
- 实现动画的原理：**通过不断控制 值 的变化，再不断 手动 赋给对象的属性，从而实现动画效果**。如图下：

![img](https:////upload-images.jianshu.io/upload_images/944365-d74ed6378954939b.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

工作原理

从上面原理可以看出：`ValueAnimator`类中有3个重要方法：

1. `ValueAnimator.ofInt（int values）`
2. `ValueAnimator.ofFloat（float values）`
3. `ValueAnimator.ofObject（int values）`

- 具体使用请看文章：[Android：这份属性动画的核心使用类ValueAnimator学习指南请收好！](https://www.jianshu.com/p/7c95342f4bc2)

- 下面我将继续讲解另外一个重要的类：`ObjectAnimator`类

------

# 5.2 ObjectAnimator类

### 5.2.1 实现动画的原理

直接对对象的属性值进行改变操作，从而实现动画效果

> 1. 如直接改变 `View`的 `alpha` 属性 从而实现透明度的动画效果
> 2. 继承自`ValueAnimator`类，即底层的动画实现机制是基于`ValueAnimator`类

- 本质原理： 通过不断控制 值 的变化，再不断 **自动** 赋给对象的属性，从而实现动画效果。如下图：

![img](https:////upload-images.jianshu.io/upload_images/944365-36c8b1b8066b0623.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

工作原理

------

从上面的工作原理可以看出：`ObjectAnimator`与 `ValueAnimator`类的区别：

- `ValueAnimator` 类是先改变值，然后 **手动赋值** 给对象的属性从而实现动画；是 **间接** 对对象属性进行操作；
- `ObjectAnimator` 类是先改变值，然后 **自动赋值** 给对象的属性从而实现动画；是 **直接** 对对象属性进行操作；

> 至于是如何自动赋值给对象的属性，下面会详细说明

- 具体使用请看文章：[Android ObjectAnimator类学习指南：手把手带你学会如何自定义属性动画](https://www.jianshu.com/p/7c95342f4bc2)

------

# 5.3 ValueAnimator类 & ObjectAnimator 类的区别

- 对比`ValueAnimator`类 & `ObjectAnimator` 类，其实二者都属于属性动画，本质上都是一致的：先改变值，然后 赋值 给对象的属性从而实现动画效果。
- 但二者的区别在于：
   `ValueAnimator` 类是先改变值，然后 **手动赋值** 给对象的属性从而实现动画；是 **间接** 对对象属性进行操作；

> `ValueAnimator` 类本质上是一种  改变 值 的操作机制

`ObjectAnimator`类是先改变值，然后 **自动赋值** 给对象的属性从而实现动画；是 **直接** 对对象属性进行操作；

> 可以理解为：`ObjectAnimator`更加智能、自动化程度更高

------

# 5.4 插值器

![img](https:////upload-images.jianshu.io/upload_images/944365-90e41bd963ae9362.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

示意图

更加具体介绍请看文章：[Android：手把手带你深入了解神秘的估值器（TypeEvaluator）](https://www.jianshu.com/p/ab5785f017b2)

------

# 5.5 估值器

![img](https:////upload-images.jianshu.io/upload_images/944365-dacfd31b2a0a7b07.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

示意图

更加具体介绍请看文章：[Android 动画：手把手带你深入了解神秘的插值器（Interpolator）](https://www.jianshu.com/p/2f19fe1e3ca1)

------

# 5.6 插值器与估值器的区别

估值器和插值器很多人容易混淆，具体区别如下：

![img](https:////upload-images.jianshu.io/upload_images/944365-b753525db783e039.png?imageMogr2/auto-orient/strip|imageView2/2/w/1140/format/webp)

示意图

------

# 6. 使用小技巧

对于属性动画的使用小技巧包括：

- 组合动画
- 快捷使用动画
- 监听动画
- 动画适配器

具体请看文章：[Android 动画：这些属性动画的使用小技巧你了解吗](https://www.jianshu.com/p/b45748963269)

至此，`Android` 动画中的`属性动画`的所有知识点都讲解完毕。

------

# 7. 总结

- 属性动画的本质原理：通过不断对值进行改变，并不断将该值赋给对象的属性，从而实现该对象在该属性上的动画效果；具体工作原理逻辑如下：

  ![img](https:////upload-images.jianshu.io/upload_images/944365-16a162a731f548d8.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

  工作原理

- 属性动画的使用主要有以下类，具体如下：

![img](https:////upload-images.jianshu.io/upload_images/944365-e75e328f7e3fab59.png?imageMogr2/auto-orient/strip|imageView2/2/w/720/format/webp)

主要使用类





目录

[TOC]

本文的目标是掌握：
1、Evaluator是什么，以及它的自定义和使用
2、Interpolator的自定义
3、知道View可以通过ViewPropertyAnimator进行属性设置



# 一、Evaluator自定义

调用ValueAnimator的**ofInt**()，**ofFloat**()或**ofObject**()静态方法创建ValueAnimator实例

在例子中，ofInt和ofFloat我们都用到了，分别用于对浮点型和整型的数据进行动画操作

那么**ofObject**()？初始对象和结束对象？如何过渡法？或者说这玩意怎么用？

首先，来了解下 Evaluator：

![image](images/%E5%8A%A8%E7%94%BB%E5%90%88%E9%9B%86%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%BF%9B%E9%98%B6/1240.png)

**用来告诉动画系统如何从初始值过渡到结束值**。IntEvaluator的源码：

![image](images/%E5%8A%A8%E7%94%BB%E5%90%88%E9%9B%86%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%BF%9B%E9%98%B6/1240-16651516189573.png)

嗯，实现了**TypeEvaluator**接口，然后重写了**evaluate()**方法，参数有三个，依次是：

*   **fraction**：动画的完成度，我们根据他来计算动画的值应该是多少
*   **startValue**：动画的起始值
*   **endValue**：动画的结束值

**动画的值 = 初始值 + 完成度 * (结束值 - 初始值)**

同样的还有FloatEvaluator，我们想告诉系统如何从初始对象过度到结束对象，那么我们就要自己来实现**TypeEvaluator**接口，即自定义Evaluator，写个例子看看：

### **2）使用示例**

**运行效果图**：

![image](images/%E5%8A%A8%E7%94%BB%E5%90%88%E9%9B%86%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%BF%9B%E9%98%B6/strip.gif)

**代码实现**：

定义一个对象**Point.java**，对象中只有x，y两个属性以及get，set方法
```java
public class Point {

    private float x;
    private float y;

    public Point() {
    }

    public Point(float x, float y) {
        this.x = x;
        this.y = y;
    }

    public float getX() {
        return x;
    }

    public float getY() {
        return y;
    }

    public void setX(float x) {
        this.x = x;
    }

    public void setY(float y) {
        this.y = y;
    }
}
```

接着自定义Evaluator类：PointEvaluator.java，实现接口重写evaluate方法

```java
public class PointEvaluator implements TypeEvaluator<Point>{
    @Override
    public Point evaluate(float fraction, Point startValue, Point endValue) {
        float x = startValue.getX() + fraction * (endValue.getX() - startValue.getX());
        float y = startValue.getY() + fraction * (endValue.getY() - startValue.getY());
        Point point = new Point(x, y);
        return point;
    }
}
```

然后自定义一个View类：AnimView.java，很简单~

```java
public class AnimView extends View {

    public static final float RADIUS = 80.0f;
    private Point currentPoint;
    private Paint mPaint;

    public AnimView(Context context) {
        this(context, null);
    }

    public AnimView(Context context, AttributeSet attrs) {
        super(context, attrs);
        init();
    }

    public AnimView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    private void init() {
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        mPaint.setColor(Color.BLUE);
    }

    private void drawCircle(Canvas canvas){
        float x = currentPoint.getX();
        float y = currentPoint.getY();
        canvas.drawCircle(x, y, RADIUS, mPaint);
    }

    private void startAnimation() {
        Point startPoint = new Point(RADIUS, RADIUS);
        Point endPoint = new Point(getWidth() - RADIUS, getHeight() - RADIUS);
        ValueAnimator anim = ValueAnimator.ofObject(new PointEvaluator(), startPoint, endPoint);
        anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
            @Override
            public void onAnimationUpdate(ValueAnimator animation) {
                currentPoint = (Point) animation.getAnimatedValue();
                invalidate();
            }
        });
        anim.setDuration(3000l);
        anim.start();
    }

    @Override
    protected void onDraw(Canvas canvas) {
        if (currentPoint == null) {
            currentPoint = new Point(RADIUS, RADIUS);
            drawCircle(canvas);
            startAnimation();
        } else {
            drawCircle(canvas);
        }
    }
}
```

最后MainActivity.java处实例化这个View即可~

```java
public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(new AnimView(this));
    }
}
```

### **3)示例增强版**

我们上面示例的基础上加上圆移动时的颜色变化~ 这里我们另外用一个ObjectAnimator来加载颜色变化的动画，我们在View中加多个 int color来控制颜色，另外写上getColor()和setColor()的方法，我们先来自定义个Evaluator吧~

**运行效果图**：

![image](images/%E5%8A%A8%E7%94%BB%E5%90%88%E9%9B%86%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E8%BF%9B%E9%98%B6/strip-16651520375898.gif)

**实现代码**：

**ColorEvaluator.java**：
```java
public class ColorEvaluator implements TypeEvaluator<Integer>{
    @Override
    public Integer evaluate(float fraction, Integer startValue, Integer endValue) {
        int alpha = (int) (Color.alpha(startValue) + fraction *
                (Color.alpha(endValue) - Color.alpha(startValue)));
        int red = (int) (Color.red(startValue) + fraction *
                (Color.red(endValue) - Color.red(startValue)));
        int green = (int) (Color.green(startValue) + fraction *
                (Color.green(endValue) - Color.green(startValue)));
        int blue = (int) (Color.blue(startValue) + fraction *
                (Color.blue(endValue) - Color.blue(startValue)));
        return Color.argb(alpha, red, green, blue);
    }
}
```

然后自定义View那里加个color，get和set方法；创建一个ObjectAnimator， 和AnimatorSet，接着把动画组合到一起就到，这里就加点东西而已，怕读者有问题， 直接另外建个View吧

AnimView2.java：
```java
public class AnimView2 extends View {

    public static final float RADIUS = 80.0f;
    private Point currentPoint;
    private Paint mPaint;
    private int mColor;

    public AnimView2(Context context) {
        this(context, null);
    }

    public AnimView2(Context context, AttributeSet attrs) {
        super(context, attrs);
        init();
    }

    public AnimView2(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    private void init() {
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        mPaint.setColor(Color.BLUE);
    }

    private void drawCircle(Canvas canvas){
        float x = currentPoint.getX();
        float y = currentPoint.getY();
        canvas.drawCircle(x, y, RADIUS, mPaint);
    }

    private void startAnimation() {
        Point startPoint = new Point(RADIUS, RADIUS);
        Point endPoint = new Point(getWidth() - RADIUS, getHeight() - RADIUS);
        ValueAnimator anim = ValueAnimator.ofObject(new PointEvaluator(), startPoint, endPoint);
        anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
            @Override
            public void onAnimationUpdate(ValueAnimator animation) {
                currentPoint = (Point) animation.getAnimatedValue();
                invalidate();
            }
        });

        ObjectAnimator objectAnimator = ObjectAnimator.ofObject(this, "color", new ColorEvaluator(), Color.BLUE, Color.RED);
        //动画集合将前面两个动画加到一起，with同时播放
        AnimatorSet animatorSet = new AnimatorSet();
        animatorSet.play(anim).with(objectAnimator);
        animatorSet.setStartDelay(1000l);
        animatorSet.setDuration(3000l);
        animatorSet.start();
    }

    @Override
    protected void onDraw(Canvas canvas) {
        if (currentPoint == null) {
            currentPoint = new Point(RADIUS, RADIUS);
            drawCircle(canvas);
            startAnimation();
        } else {
            drawCircle(canvas);
        }
    }

    //color的get和set方法~
    public int getColor() {
        return mColor;
    }

    public void setColor(int color) {
        mColor = color;
        mPaint.setColor(color);
    }
}
```
然后MainActivity，setContentView那里把AnimView改成AnimView2就好

注：
getWidth()，getHeight()在构造方法中取的话，其值还是0，0。在onMeasure后才有值，因此动画的启动要放到onDraw里面。

# 二、自定义Interpolator

```java
private class DecelerateAccelerateInterpolator implements TimeInterpolator {
    @Override
    public float getInterpolation(float input) {
        if (input < 0.5) {
            return (float) (Math.sin(input * Math.PI) / 2);
        } else {
            return 1 - (float) (Math.sin(input * Math.PI) / 2);
        }
    }
}
```

# 三、ViewPropertyAnimator

3.1后系统当中附增的一个新的功能，为View的动画操作提供一种更加便捷的用法。假如是以前，让一个TextView从正常状态变成透明状态，会这样写：

```java
ObjectAnimator animator = ObjectAnimator.ofFloat(textview, "alpha", 0f);  
animator.start();
```
而使用ViewPropertyAnimator来实现同样的效果则显得更加易懂：
```java
textview.animate().alpha(0f); 
```
还支持连缀用法，组合多个动画，设定时长，设置Interpolator等~
```java
textview.animate().x(500).y(500).setDuration(5000)  
        .setInterpolator(new BounceInterpolator());
```

# 四、总结

Evaluator的自定义其实就是我们自己定义数值的变化规律。

要熟练掌握动画，还是需要多撸代码，熟练了就简单了。





# Android动画：手把手带你学会如何自定义属性动画(ObjectAnimator类)

# 前言

- 属性动画的使用 是 `Android` 开发中常用的知识
- 今天，我将讲解属性动画使用中最核心的一个方法类：`ObjectAnimator`，希望你们会喜欢。

> Carson带你学`Android`动画系列文章：
>  [Carson带你学Android：一份全面&详细的动画知识学习攻略](https://www.jianshu.com/p/53759778284a)
>  [Carson带你学Android：常见的三种动画类型](https://www.jianshu.com/p/53759778284a)
>  [Carson带你学Android：补间动画学习教程](https://www.jianshu.com/p/733532041f46)
>  [Carson带你学Android：属性动画学习教程](https://www.jianshu.com/p/2412d00a0ce4)
>  [Carson带你学Android：逐帧动画学习教程](https://www.jianshu.com/p/225fe1feba60)
>  [Carson带你学Android：自定义动画神器-估值器(含实例教学)](https://www.jianshu.com/p/ab5785f017b2)
>  [Carson带你学Android：自定义动画神器-插值器(含实例教学)](https://www.jianshu.com/p/2f19fe1e3ca1)

------

# 目录

![img](https:////upload-images.jianshu.io/upload_images/944365-4c52d85a5cfb3e14.png?imageMogr2/auto-orient/strip|imageView2/2/w/728/format/webp)

示意图

------

# 储备知识

阅读本文前，请先阅读文章：[Android：这是一份全面 & 详细的动画入门学习指南](https://www.jianshu.com/p/35d25cc205e7)

------

# 1. 简介

- 实现属性动画中的一个核心方法类
- 继承自ValueAnimator类，即底层的动画实现机制是基于ValueAnimator类

------

# 2. 实现动画的原理

直接对对象的属性值进行改变操作，从而实现动画效果

> 如直接改变 `View`的 `alpha` 属性 从而实现透明度的动画效果

------

# 3. 本质原理

通过不断控制 值 的变化，再不断 **自动** 赋给对象的属性，从而实现动画效果。如下图：

![img](https:////upload-images.jianshu.io/upload_images/944365-376944a7ec5a09af.png?imageMogr2/auto-orient/strip|imageView2/2/w/1088/format/webp)

示意图

从上面的工作原理可以看出：`ObjectAnimator`与 `ValueAnimator`类的区别：

- `ValueAnimator` 类是先改变值，然后 **手动赋值** 给对象的属性从而实现动画；是 **间接** 对对象属性进行操作；具体请看文章：[Android：这份Android核心使用类ValueAnimator学习指南请收好！](https://www.jianshu.com/p/7c95342f4bc2)
- `ObjectAnimator` 类是先改变值，然后 **自动赋值** 给对象的属性从而实现动画；是 **直接** 对对象属性进行操作；

> 至于是如何自动赋值给对象的属性，下面会详细说明

------

# 4. 基础使用

### 4.1 使用步骤

由于是继承了ValueAnimator类，所以使用的方法十分类似：`XML` 设置 /  `Java`设置



```csharp
/*
 * 设置方式1：Java
 */
 // 步骤1：创建ObjectAnimator对象
     ObjectAnimator animator = ObjectAnimator.ofFloat(Object object, String property, float ....values);  
    // 作用：
    // 1. 创建动画实例
    // 2. 参数设置：
    // Object object：需要操作的对象
    // String property：需要操作的对象的属性
    // float ....values：动画初始值 & 结束值（不固定长度）
    // 若是两个参数a,b，则动画效果则是从属性的a值到b值
    // 若是三个参数a,b,c，则则动画效果则是从属性的a值到b值再到c值
    // 以此类推
    // 至于如何从初始值过渡到结束值，同样是由估值器决定，此处ObjectAnimator.ofFloat()是有系统内置的浮点型估值器FloatEvaluator，同ValueAnimator讲解

// 步骤2：设置动画属性
    // 设置动画运行的时长
    anim.setDuration(500);
    
    // 设置动画延迟播放时间
    anim.setStartDelay(500);
    
    // 设置动画重复播放次数 = 重放次数+1
    // 动画播放次数 = infinite时,动画无限重复
    anim.setRepeatCount(0);
    
    // 设置重复播放动画模式
    anim.setRepeatMode(ValueAnimator.RESTART);
    // ValueAnimator.RESTART(默认):正序重放
    // ValueAnimator.REVERSE:倒序回放

// 步骤3：启动动画
animator.start();  

/*
 * 设置方式2：xml
 */
 // 步骤1：在路径 res/animator 的文件夹里创建动画效果.xml文件
 // set_animation.xml

 // 步骤2：设置动画参数
 // ObjectAnimator 采用<animator>  标签
    <objectAnimator xmlns:android="http://schemas.android.com/apk/res/android"  
        android:valueFrom="1"   // 初始值
        android:valueTo="0"  // 结束值
        android:valueType="floatType"  // 变化值类型 ：floatType & intType
        android:propertyName="alpha" // 对象变化的属性名称
    /> 

// 步骤3：启动动画
    // 1. 载入XML动画
    Animator animator = AnimatorInflater.loadAnimator(context, R.animator.view_animation);  
    // 2. 设置动画对象
    animator.setTarget(view);  
    // 3. 启动动画
    animator.start();  
```

### 4.2 使用实例

此处先展示四种基本变换：平移、旋转、缩放 & 透明度

#### 平移



```cpp
// 1. 创建动画作用对象：此处以Button为例
Button mButton = (Button) findViewById(R.id.Button);

// 2. 获得当前按钮的位置
float curTranslationX = mButton.getTranslationX();

// 3. 创建动画对象
ObjectAnimator animator = ObjectAnimator.ofFloat(mButton, "translationX", curTranslationX, 300,curTranslationX);

// 表示的是:
// 动画作用对象是mButton
// 动画作用的对象的属性是X轴平移（在Y轴上平移同理，采用属性"translationY"
// 动画效果是:从当前位置平移到 x=1500 再平移到初始位置

// 4. 设置动画时长
animator.setDuration(5000);

// 5. 启动动画
animator.start();
```

![img](https:////upload-images.jianshu.io/upload_images/944365-9ccbc93c0591bebc.gif?imageMogr2/auto-orient/strip|imageView2/2/w/388/format/webp)

属性动画 - X轴平移.gif

#### 旋转



```cpp
// 1. 创建动画作用对象：此处以Button为例
Button mButton = (Button) findViewById(R.id.Button);

// 2. 创建动画对象
ObjectAnimator animator = ObjectAnimator.ofFloat(mButton, "rotation", 0f, 360f);
// 表示的是:
// 动画作用对象是mButton
// 动画作用的对象的属性是旋转alpha
// 动画效果是:0度-360度

// 3. 设置动画时长
animator.setDuration(5000);

// 4. 启动动画
animator.start();
```

![img](https:////upload-images.jianshu.io/upload_images/944365-3afd2ec909521458.gif?imageMogr2/auto-orient/strip|imageView2/2/w/388/format/webp)

属性动画- 旋转.gif

#### 缩放



```cpp
// 1. 创建动画作用对象：此处以Button为例
Button mButton = (Button) findViewById(R.id.Button);

// 2. 创建动画对象
ObjectAnimator animator = ObjectAnimator.ofFloat(mButton, "scaleX", 1f, 3f, 1f);
// 表示的是:
// 动画作用对象是mButton
// 动画作用的对象的属性是X轴缩放
// 动画效果是:放大到3倍,再缩小到初始大小

// 3. 设置动画时长
animator.setDuration(5000);

// 4. 启动动画
animator.start();
```

![img](https:////upload-images.jianshu.io/upload_images/944365-f77663d1b955f010.gif?imageMogr2/auto-orient/strip|imageView2/2/w/388/format/webp)

属性动画 - 缩放.gif

#### 透明度



```cpp
// 1. 创建动画作用对象：此处以Button为例
Button mButton = (Button) findViewById(R.id.Button);

// 2. 创建动画对象
ObjectAnimator animator = ObjectAnimator.ofFloat(mButton, "alpha", 1f, 0f, 1f);
// 表示的是:
// 动画作用对象是mButton
// 动画作用的对象的属性是透明度alpha
// 动画效果是:常规 - 全透明 - 常规

// 3. 设置动画时长
animator.setDuration(5000);

// 4. 启动动画
animator.start();
```

![img](https:////upload-images.jianshu.io/upload_images/944365-f022260060ab6cd8.gif?imageMogr2/auto-orient/strip|imageView2/2/w/388/format/webp)

属性动画 - 透明度.gif

------

# 4. 通过自定义对象属性实现动画效果

在上面的基础使用中，我们对于ObjectAnimator.ofFloat()的第二个参数传入了：alpha、rotation、translationX 和 scaleY等对象的属性值，从而实现了平移、旋转、缩放、透明度的动画。

实际上，这个参数是可以传入对象的**任意属性值**的，因为ObjectAnimator类实现动画效果的本质是：**通过不断控制值的变化，再不断自动赋值给对象的属性。**

![img](https:////upload-images.jianshu.io/upload_images/944365-7adf6ee408a81f5c.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

工作原理

而 **自动赋给对象的属性的本质是调用该对象属性的set() 、get()方法进行赋值**。所以，`ObjectAnimator.ofFloat(Object object, String property, float ....values)`的第二个参数传入值的作用是：**让`ObjectAnimator`类根据传入的属性名去寻找该对象对应属性名的 set() 、get()方法，从而进行对象属性值的赋值**。如上面的例子：



```csharp
ObjectAnimator animator = ObjectAnimator.ofFloat(mButton, "rotation", 0f, 360f);
// 其实Button对象中并没有rotation这个属性值
// ObjectAnimator并不是直接对我们传入的属性名进行操作
// 而是根据传入的属性值"rotation" 去寻找对象对应属性名对应的get和set方法，从而通过set()、get()对属性进行赋值

// 因为Button对象中有rotation属性所对应的get & set方法
// 所以传入的rotation属性是有效的
// 所以才能对rotation这个属性进行操作赋值
public void setRotation(float value);  
public float getRotation();  

// 实际上，这两个方法是由View对象提供的，所以任何继承自View的对象都具备这个属性
```

### 4.1 原理解析

至于是如何进行自动赋值，直接看源码分析：从启动动画的animator.start()方法开始。



```csharp
@Override  
public void start() {  
    AnimationHandler handler = sAnimationHandler.get();  

    ...
    
    super.start();  
   // 调用父类的start()
   // 因为ObjectAnimator类继承ValueAnimator类，所以调用的是ValueAnimator的star()
   // 经过层层调用，最终会调用到 自动赋值给对象属性值的方法 ->关注1
}  

/*
 * 关注1：自动赋值给对象属性值的逻辑方法
 */
// 步骤1：初始化动画值
private void setupValue(Object target, Keyframe kf) {  
    if (mProperty != null) {  
        kf.setValue(mProperty.get(target));  
        // 初始化时，如果属性的初始值没有提供，则调用属性的get()进行取值
    }  
        kf.setValue(mGetter.invoke(target));   
    }  
}  

// 步骤2：更新动画值
// 当动画下一帧来时（即动画更新的时候），setAnimatedValue()都会被调用
void setAnimatedValue(Object target) {  
    if (mProperty != null) {  
        mProperty.set(target, getAnimatedValue());  
        // 内部调用对象该属性的set()，从而将新的属性值设置给对象属性
    }   
}  
```

从上面的源码分析可以看出自动赋值的逻辑是：

- 初始化时，若属性的初始值没有提供，则调用属性的 `get()`进行取值；
- 当值变化时，会调用对象该属性的 `set()`方法，从而将新的属性值设置给对象属性。

所以：

- `ObjectAnimator` 类针对的是**任意对象 & 任意属性值**，并不是单单针对于View对象
- 如果需要采用`ObjectAnimator` 类实现动画效果，那么需要操作的对象就必须有该属性的set()、get()

- 同理，针对上述另外的四种基本动画效果，`View` 也存在着对应的set()、get()方法，如旋转属性的`setRotation()`、`getRotation()`、平移属性的`setTranslationX()`、`getTranslationX()`、缩放属性的`setScaleY()`、`getScaleY()`

------

### 4.2 具体使用

对于属性动画，其拓展性在于：不局限于系统限定的动画且可以自定义动画(即自定义对象的属性)，并通过操作自定义的属性从而实现各种复杂多样的动画效果。

那么，该如何自定义属性呢？本质上分为两个步骤：

1. 为对象设置需要操作属性的set()、get()方法；
2. 通过自定义估值器(实现TypeEvaluator类接口）从而定义属性变化的逻辑。

在属性值变化的时候，会自动调用属性的set()、get()方法进行赋值，从而实现动画效果。

### 4.3 实例讲解

下面，我将用一个实例来说明如何通过自定义属性实现动画效果：一个圆的颜色渐变，即此处要变化、操作的对象属性值是圆的背景颜色

![img](https:////upload-images.jianshu.io/upload_images/944365-3bdaacdd53e7bc30.gif?imageMogr2/auto-orient/strip|imageView2/2/w/386/format/webp)

属性动画 - 颜色变化

- 自定义属性的逻辑如下：（需要自定义属性为圆的背景颜色）

![img](https:////upload-images.jianshu.io/upload_images/944365-08d6618df6368369.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

自定义属性的逻辑

# 步骤1：设置对象类属性的set() 、get()

即此处要变化、操作的对象属性值是圆的背景颜色。共有两种方法：

- 直接法：通过继承原始类，直接给类加上该属性的get()、set()方法；
- 间接法：通过包装原始动画对象，间接给对象加上该属性的get()、set()方法。即用一个类来包装原始对象。

此处主要使用第一种方式进行展示。



```java
// MyView2.java
public class MyView2 extends View {
    public static final float RADIUS = 100f;// 圆的半径 = 100
    
     // 画笔相关
    private Paint mPaint;

    // 初始化画笔
    public MyView2(Context context, AttributeSet attrs) {
        super(context, attrs);
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        mPaint.setColor(Color.BLUE);
    }

    // 背景颜色属性
    private String color;

    // 设置背景颜色的get()方法
    public String getColor() {
        return color;
    }

    // 设置背景颜色的set()方法
    public void setColor(String color) {
        this.color = color;

        // 将画笔的颜色设置成可传入颜色的参数
        mPaint.setColor(Color.parseColor(color));
        
        // 调用了invalidate(),即画笔颜色每次改变都会刷新视图，然后调用onDraw()方法重新绘制圆
        // 而因为每次调用onDraw()方法时画笔的颜色都会改变,所以圆的颜色也会改变，从而实现动画效果
        invalidate();
    }

    // 复写onDraw()从而实现绘制逻辑
    // 绘制逻辑:先在初始点画圆,通过监听当前坐标值(currentPoint)的变化,每次变化都调用onDraw()重新绘制圆,从而实现圆的平移动画效果
    @Override
    protected void onDraw(Canvas canvas) {
        canvas.drawCircle(500, 500, RADIUS, mPaint);
    }
 
}
```

# 步骤2：在布局文件加入自定义View控件

*activity_main.xml*



```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:paddingBottom="@dimen/activity_vertical_margin"
    android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    tools:context="scut.carson_ho.valueanimator_ofobject.MainActivity">

    <scut.carson_ho.valueanimator_ofobject.MyView2
        android:id="@+id/MyView2"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
         />
</RelativeLayout>
```

# 步骤3：自定义估值器

即通过实现TypeEvaluator类接口从而定义属性变化的逻辑。此处要定义的是：实现颜色过渡的逻辑。



```cpp
// ColorEvaluator.java

public class ColorEvaluator implements TypeEvaluator {
    // 实现TypeEvaluator接口

    private int mCurrentRed;
    private int mCurrentGreen ;
    private int mCurrentBlue ;

    // 复写evaluate（）
    // 作用：写入对象动画过渡的逻辑，此处是写颜色过渡的逻辑
    @Override
    public Object evaluate(float fraction, Object startValue, Object endValue) {

        // 获取到颜色的初始值和结束值
        String startColor = (String) startValue;
        String endColor = (String) endValue;

        // 通过字符串截取的方式将初始化颜色分为RGB三个部分，并将RGB的值转换成十进制数字
        // 那么每个颜色的取值范围就是0-255
        int startRed = Integer.parseInt(startColor.substring(1, 3), 16);
        int startGreen = Integer.parseInt(startColor.substring(3, 5), 16);
        int startBlue = Integer.parseInt(startColor.substring(5, 7), 16);

        int endRed = Integer.parseInt(endColor.substring(1, 3), 16);
        int endGreen = Integer.parseInt(endColor.substring(3, 5), 16);
        int endBlue = Integer.parseInt(endColor.substring(5, 7), 16);

        // 将初始化颜色的值定义为当前需要操作的颜色值
        mCurrentRed = startRed;
        mCurrentGreen = startGreen;
        mCurrentBlue = startBlue;

        // 计算初始颜色和结束颜色之间的差值
        // 该差值决定着颜色变化的快慢:初始颜色值和结束颜色值很相近，那么颜色变化就会比较缓慢;否则,变化则很快
        // 具体如何根据差值来决定颜色变化快慢的逻辑写在getCurrentColor()里.
        int redDiff = Math.abs(startRed - endRed);
        int greenDiff = Math.abs(startGreen - endGreen);
        int blueDiff = Math.abs(startBlue - endBlue);
        int colorDiff = redDiff + greenDiff + blueDiff;

        if (mCurrentRed != endRed) {
            mCurrentRed = getCurrentColor(startRed, endRed, colorDiff, 0,
                    fraction);
                    // getCurrentColor()决定如何根据差值来决定颜色变化的快慢 ->>关注1
        } else if (mCurrentGreen != endGreen) {
            mCurrentGreen = getCurrentColor(startGreen, endGreen, colorDiff,
                    redDiff, fraction);
        } else if (mCurrentBlue != endBlue) {
            mCurrentBlue = getCurrentColor(startBlue, endBlue, colorDiff,
                    redDiff + greenDiff, fraction);
        }

        // 将计算出的当前颜色的值组装返回
        String currentColor = "#" + getHexString(mCurrentRed)
                + getHexString(mCurrentGreen) + getHexString(mCurrentBlue);

        // 由于我们计算出的颜色是十进制数字，所以需要转换成十六进制字符串:调用getHexString()->>关注2
        // 最终将RGB颜色拼装起来,并作为最终的结果返回
        return currentColor;
    }


    // 关注1:getCurrentColor()
    // 具体是根据fraction值来计算当前的颜色。
    private int getCurrentColor(int startColor, int endColor, int colorDiff,
                                int offset, float fraction) {
        int currentColor;
        if (startColor > endColor) {
            currentColor = (int) (startColor - (fraction * colorDiff - offset));
            if (currentColor < endColor) {
                currentColor = endColor;
            }
        } else {
            currentColor = (int) (startColor + (fraction * colorDiff - offset));
            if (currentColor > endColor) {
                currentColor = endColor;
            }
        }
        return currentColor;
    }

    // 关注2:将10进制颜色值转换成16进制。
    private String getHexString(int value) {
        String hexString = Integer.toHexString(value);
        if (hexString.length() == 1) {
            hexString = "0" + hexString;
        }
        return hexString;
    }
}
```

# 步骤4：启动动画



```java
// MainActivity.java
public class MainActivity extends AppCompatActivity {

    MyView2 myView2; // 自定义的view

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // 1. 设置自定义View对象
        // 传入背景颜色属性值 & 颜色估值器
        myView2 = (MyView2) findViewById(R.id.MyView2);
        ObjectAnimator anim = ObjectAnimator.ofObject(myView2, "color", new ColorEvaluator(),
                "#0000FF", "#FF0000");
        
        // 本质逻辑：
        // 步骤1：根据颜色估值器不断 改变 值 
        // 步骤2：调用set()设置背景颜色的属性值（实际上是通过画笔进行颜色设置）
        // 步骤3：调用invalidate()刷新视图，即调用onDraw()重新绘制，从而实现动画效果

        // 2. 设置动画时长
        anim.setDuration(8000);

        // 3. 启动动画
        anim.start();
    }
}
```

### 效果图

![img](https:////upload-images.jianshu.io/upload_images/944365-3bdaacdd53e7bc30.gif?imageMogr2/auto-orient/strip|imageView2/2/w/386/format/webp)

属性动画 - 颜色变化

# 源码地址

[Carson_Ho的Github地址](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FCarson-Ho%2FPropertyAnimator_ofObject)

------

# 5. 特别说明

对于手动设置对象类属性的 set()、get()

- 直接法：通过继承原始类，直接给类加上该属性的get()、set()方法；
- 间接法：通过包装原始动画对象，间接给对象加上该属性的get()、set()方法。即用一个类来包装原始对象。

对于该对象本身无这个属性时，一般是采用使用第一种方式，即上述实例说明。那么什么情况下会使用第二种方式，即间接法呢？

答案：**当该属性存在set()方法但该set()方法无法带来预期的UI变化时。**

### 5.1 示例说明

- 由于`View`的`setWidth()`并不是设置`View`的宽度，而是设置`View`的最大宽度和最小宽度的；
- 所以通过`setWidth()`无法改变控件的宽度；
- 即对`View`视图的`width`做属性动画没有效果

具体请看下面按钮的例子，设置后该按钮不会有任何动画效果变化。



```cpp
// 创建动画作用对象：此处以Button为例
// 此Button的宽高设置具体为具体宽度200px
Button mButton = (Button) findViewById(R.id.Button);

// 对该button设置宽度变化
ObjectAnimator.ofInt(mButton, "width", 500).setDuration(5000).start();
```

因为button的setWidth()是用于设置最大、最小宽度的，而不是设置即时宽度的。

![img](https:////upload-images.jianshu.io/upload_images/944365-1a6e1c2ebb554772.gif?imageMogr2/auto-orient/strip|imageView2/2/w/386/format/webp)

效果图：不会有动画效果



```java
public void setWidth(int pixels) {  
    mMaxWidth = mMinWidth = pixels;  
    mMaxWidthMode = mMinWidthMode = PIXELS;  
    // 因为setWidth（）并不是设置View的宽度，而是设置Button的最大宽度和最小宽度的
    // 所以通过setWidth（）无法改变控件的宽度
   // 所以对width属性做属性动画没有效果
  
    requestLayout();  
    invalidate();  
}  

// 但getWidth的确是获取View的宽度
@ViewDebug.ExportedProperty(category = "layout")  
public final int getWidth() {  
    return mRight - mLeft;  
}  
```

### 5.2 解决方案

通过包装原始动画对象，间接给对象加上该属性的get()、set()方法。即用一个类来包装原始对象。

> 本质上是采用了设计模式中的装饰模式，即通过包装类从而扩展对象的功能



```java
// MainActivity.java
public class MainActivity extends AppCompatActivity {

    Button mButton;
    ViewWrapper wrapper;

    // 1. 提供ViewWrapper类,用于包装View对象
    // 本例:包装Button对象
    private static class ViewWrapper {
        private View mTarget;

        // 构造方法:传入需要包装的对象
        public ViewWrapper(View target) {
            mTarget = target;
        }

        // 为view的宽度设置get()、set()
        public int getWidth() {
            return mTarget.getLayoutParams().width;
        }

        public void setWidth(int width) {
            mTarget.getLayoutParams().width = width;
            mTarget.requestLayout();
        }
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // 2. 创建动画作用对象
        // 以以Button为例
        mButton = (Button) findViewById(R.id.Button);
    
        // 3. 创建包装类,并传入动画作用的对象
        wrapper = new ViewWrapper(mButton);
        
        // 4. 点击时设置动画的对象是包装类的对象
        mButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                ObjectAnimator.ofInt(wrapper, "width", 500).setDuration(3000).start();
            }
        });
    }  
}
```

## 效果图

![img](https:////upload-images.jianshu.io/upload_images/944365-7889934974344381.gif?imageMogr2/auto-orient/strip|imageView2/2/w/386/format/webp)

效果图 - 动画有效

------

# 6. 与`ValueAnimator`类对比

对比于属性动画中另外一个比较核心的使用类：`ValueAnimator`类：

### 6.1 相同点

其二者的本质都是相同：不断改变值，然后不断赋值给对象的属性从而实现动画效果

### 6.2 区别

二者的区别在于：赋值给对象属性的操作是直接还是间接的。

- ValueAnimator类：不断改变值，然后手动赋值给对象的属性从而实现动画效果，是间接对对象属性进行操作；
- ObjectAnimator类：不断改变值，然后自动赋值给对象的属性从而实现动画效果，是直接对对象属性进行操作；

可以理解为：ObjectAnimator类的使用更加智能、自动化程度更高。

至此，关于属性动画中的核心使用类`ObjectAnimator`讲解完毕



# Carson带你学Android：这些属性动画的使用小技巧你了解吗

# 前言

- 属性动画的使用 是 `Android` 开发中常用的知识
- 今天，我将讲解属性动画使用中的一些使用小技巧，希望你们会喜欢。

> Carson带你学`Android`动画系列文章：
>  [Carson带你学Android：一份全面&详细的动画知识学习攻略](https://www.jianshu.com/p/53759778284a)
>  [Carson带你学Android：常见的三种动画类型](https://www.jianshu.com/p/53759778284a)
>  [Carson带你学Android：补间动画学习教程](https://www.jianshu.com/p/733532041f46)
>  [Carson带你学Android：属性动画学习教程](https://www.jianshu.com/p/2412d00a0ce4)
>  [Carson带你学Android：逐帧动画学习教程](https://www.jianshu.com/p/225fe1feba60)
>  [Carson带你学Android：自定义动画神器-估值器(含实例教学)](https://www.jianshu.com/p/ab5785f017b2)
>  [Carson带你学Android：自定义动画神器-插值器(含实例教学)](https://www.jianshu.com/p/2f19fe1e3ca1)

------

# 目录

![img](https:////upload-images.jianshu.io/upload_images/944365-e9019a30f9a98b50.png?imageMogr2/auto-orient/strip|imageView2/2/w/920/format/webp)

示意图

------

# 储备知识

属性动画简介：[Android 属性动画：这是一篇全面 & 详细的 属性动画 总结&攻略](https://www.jianshu.com/p/2412d00a0ce4)

------

# 1. 组合动画

### 1.1 简介

单一动画实现的效果相当有限，更多的使用场景是同时使用多种动画效果，即组合动画

### 1.2 具体使用

实现 组合动画 的功能：`AnimatorSet`类



```css
AnimatorSet.play(Animator anim)   ：播放当前动画
AnimatorSet.after(long delay)   ：将现有动画延迟x毫秒后执行
AnimatorSet.with(Animator anim)   ：将现有动画和传入的动画同时执行
AnimatorSet.after(Animator anim)   ：将现有动画插入到传入的动画之后执行
AnimatorSet.before(Animator anim) ：  将现有动画插入到传入的动画之前执行
```

### 1.3 实例讲解

主要动画是平移，平移过程中伴随旋转动画，平移完后进行透明度变化

> 实现方式有 `XML`设置  / `Java`代码设置

#### 设置方式1：`Java`代码设置



```dart
// 步骤1：设置需要组合的动画效果
ObjectAnimator translation = ObjectAnimator.ofFloat(mButton, "translationX", curTranslationX, 300,curTranslationX);  
// 平移动画
ObjectAnimator rotate = ObjectAnimator.ofFloat(mButton, "rotation", 0f, 360f);  
// 旋转动画
ObjectAnimator alpha = ObjectAnimator.ofFloat(mButton, "alpha", 1f, 0f, 1f);  
// 透明度动画

// 步骤2：创建组合动画的对象
AnimatorSet animSet = new AnimatorSet();  

// 步骤3：根据需求组合动画
animSet.play(translation).with(rotate).before(alpha);  
animSet.setDuration(5000);  

// 步骤4：启动动画
animSet.start();  
```

### 效果图

![img](https:////upload-images.jianshu.io/upload_images/944365-a27607d0dd6eb8d9.gif?imageMogr2/auto-orient/strip|imageView2/2/w/392/format/webp)

组合动画.gif

#### 设置方式2：`XML`设置

- 步骤1：在 `res/animator`的文件夹里创建动画`.xml`文件

> 此处为 `res/animator/set_animation.xml`

- 步骤2：设置动画效果

*set_animation.xml*



```xml
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android"
    android:ordering="sequentially" >
    // 表示Set集合内的动画按顺序进行
    // ordering的属性值:sequentially & together
    // sequentially:表示set中的动画，按照先后顺序逐步进行（a 完成之后进行 b ）
    // together:表示set中的动画，在同一时间同时进行,为默认值

    <set android:ordering="together" >
        // 下面的动画同时进行
        <objectAnimator
            android:duration="2000"
            android:propertyName="translationX"
            android:valueFrom="0"
            android:valueTo="300"
            android:valueType="floatType" >
        </objectAnimator>
        
        <objectAnimator
            android:duration="3000"
            android:propertyName="rotation"
            android:valueFrom="0"
            android:valueTo="360"
            android:valueType="floatType" >
        </objectAnimator>
    </set>

        <set android:ordering="sequentially" >
            // 下面的动画按序进行
            <objectAnimator
                android:duration="1500"
                android:propertyName="alpha"
                android:valueFrom="1"
                android:valueTo="0"
                android:valueType="floatType" >
            </objectAnimator>
            <objectAnimator
                android:duration="1500"
                android:propertyName="alpha"
                android:valueFrom="0"
                android:valueTo="1"
                android:valueType="floatType" >
            </objectAnimator>
        </set>

</set>
```

在Java代码中启动动画



```kotlin
mButton = (Button) findViewById(R.id.Button);
        // 创建动画作用对象：此处以Button为例

        AnimatorSet animator = (AnimatorSet) AnimatorInflater.loadAnimator(this, R.animator.set_animation);
// 创建组合动画对象  &  加载XML动画
        animator.setTarget(mButton);
        // 设置动画作用对象
        animator.start();
        // 启动动画
```

------

# 2. 快捷使用

### 2.1 简介

- 从属性动画的原理可知，属性动画的本质是：对值进行操作
- 但`Java`是面向对象的，所以 `Google` 团队添加面向对象操作的属性动画使用 - `ViewPropertyAnimator`类

> 可认为是属性动画的一种简写、快捷使用方式

### 2.2 具体使用



```cpp
View.animate().xxx().xxx();
// ViewPropertyAnimator的功能建立在animate()上
// 调用animate()方法返回值是一个ViewPropertyAnimator对象,之后的调用的所有方法都是通过该实例完成
// 调用该实例的各种方法来实现动画效果
// ViewPropertyAnimator所有接口方法都使用连缀语法来设计，每个方法的返回值都是它自身的实例
// 因此调用完一个方法后可直接连缀调用另一方法,即可通过一行代码就完成所有动画效果
```

### 2.3 实例讲解



```cpp
mButton = (Button) findViewById(R.id.Button);
// 创建动画作用对象：此处以Button为例

mButton.animate().alpha(0f);
// 单个动画设置:将按钮变成透明状态 
mButton.animate().alpha(0f).setDuration(5000).setInterpolator(new BounceInterpolator());
// 单个动画效果设置 & 参数设置 
mButton.animate().alpha(0f).x(500).y(500);
// 组合动画:将按钮变成透明状态再移动到(500,500)处

// 特别注意:
// 动画自动启动,无需调用start()方法.因为新的接口中使用了隐式启动动画的功能，只要我们将动画定义完成后，动画就会自动启动
// 该机制对于组合动画也同样有效，只要不断地连缀新的方法，那么动画就不会立刻执行，等到所有在ViewPropertyAnimator上设置的方法都执行完毕后，动画就会自动启动
// 如果不想使用这一默认机制，也可以显式地调用start()方法来启动动画
```

------

# 3. 监听动画

### 3.1 简介

- `Animation`类通过监听动画开始 / 结束 / 重复 / 取消时刻来进行一系列操作，如跳转页面等等

### 3.2 具体使用

- 通过在`Java`代码里`addListener（）`设置



```java
      Animation.addListener(new AnimatorListener() {
          @Override
          public void onAnimationStart(Animation animation) {
              //动画开始时执行
          }
      
           @Override
          public void onAnimationRepeat(Animation animation) {
              //动画重复时执行
          }

         @Override
          public void onAnimationCancel()(Animation animation) {
              //动画取消时执行
          }
    
          @Override
          public void onAnimationEnd(Animation animation) {
              //动画结束时执行
          }
      });

// 特别注意：每次监听必须4个方法都重写。
```

### 3.3 特别注意

- 因`Animator`类、`AnimatorSet`类、`ValueAnimator`、`ObjectAnimator`类存在以下继承关系

![img](https:////upload-images.jianshu.io/upload_images/944365-56dfb73edfed1293.png?imageMogr2/auto-orient/strip|imageView2/2/w/530/format/webp)

各类继承关系

- 所以`AnimatorSet`类、`ValueAnimator`、`ObjectAnimator`都可以使用`addListener()`监听器进行动画监听

------

# 4. 动画适配器

### 4.1 背景

有些时候我们并不需要监听动画的所有时刻

### 4.2 问题

但`addListener(new AnimatorListener())`监听器是必须重写4个时刻方法，这使得接口方法重写太累赘

### 4.3 解决方案

采用动画适配器（`AnimatorListenerAdapter`），解决**实现接口繁琐** 的问题



```java
anim.addListener(new AnimatorListenerAdapter() {  
// 向addListener()方法中传入适配器对象AnimatorListenerAdapter()
// 由于AnimatorListenerAdapter中已经实现好每个接口
// 所以这里不实现全部方法也不会报错
    @Override  
    public void onAnimationStart(Animator animation) {  
    // 如想只想监听动画开始时刻，就只需要单独重写该方法就可以
    }  
});  
```

至此，关于`Android` 动画中`属性动画`的使用小技巧讲解完毕。

------

# 5. 总结

- 本文对`Android` 属性动画中的使用小技巧进行了全面 & 详细介绍



# 参考

[Carson带你Android：这是一篇全面&详细的属性动画学习指南](https://www.jianshu.com/p/2412d00a0ce4)

[Android：属性动画核心使用-ValueAnimator类学习指南](https://www.jianshu.com/p/7c95342f4bc2)

[Android动画：手把手带你学会如何自定义属性动画(ObjectAnimator类)](https://www.jianshu.com/p/bce3f1d4e1f2)

[Carson带你学Android：这些属性动画的使用小技巧你了解吗](https://www.jianshu.com/p/b45748963269)
