> version：2021/11/02
>
> review：



目录

[TOC]



# 一、内存泄漏

## 1、内存泄漏与内存溢出的区别

* 内存泄漏：指程序在申请内存后，被某个对象一直持有，导致无法释放已申请的内存空间。一次内存泄漏的危害可以忽略，但内存泄漏堆积后果很严重，无论多少内存，迟早会被占光。**内存泄漏的本质是该销毁的对象因为被其他引用持有，导致不能GC掉。**或者说，生命周期短的对象被生命周期长的引用持有。
* 内存溢出：指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory。Android系统为每个应用程序申请到的内存有限，一般为64M或者128M等，我们可以在清单文件中进行配置，android:largeheap = "true" 从而给APP申请更大的内存空间。

![JVM与Android关系](images/9000209-10390b8033ee3a45.png)

虚拟机：JVM的作用是把平台无关的.class里面的字节码翻译成平台相关的机器码，来实现跨平台。Dalvik和Art时安卓中使用的虚拟机。
注：本地方法栈，属于native层，暂不需要管，它和Java层是不一样的垃圾回收机制。

内存溢出会发生在堆内存和虚拟机栈：

* 堆内存溢出
  例1：
  ![堆内存溢出示例1](images/9000209-bed579715f55ba4b.png)
  例2：如生产者与消费者模型，如注册回调，忘记注销。添加到队列，忘记控制队列大小。
  例3：fastjson解析（间接）循环引用。（这里例子还不是很理解，没有遇到过）

* 栈（虚拟栈）内存溢出
  方法递归。

OOM会发生在方法区、堆内存和虚拟机栈。

## 2、内存泄漏场景（6大类）

**（1）单例使用不当（生命周期不一样）**

说明：单例的静态特性使得它的生命周期同应用的生命周期一样长，如果一个对象已经没有用处了，但是单例还持有它的引用，那么在整个应用程序的生命周期它都不能正常被回收，从而导致内存泄漏。

```java
public class AppSetting {
    private static AppSetting mInstance;
    private Context mContext;

    private AppSetting(Context context) {
        this.mContext = context;
    }

    public static AppSetting getInstance(Context context) {
        if (mInstance == null) {
            mInstance = new AppSetting(context);
        }
        return mInstance;
    }
}

//使用
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        AppSetting.getInstance(this);
    }
}
```

解决：
将AppSetting修改如下：

```java
public class AppSetting {
    private static AppSetting mInstance;
    private Context mContext;

    private AppSetting(Context context) {
        this.mContext = context.getApplicationContext();
    }

    public static AppSetting getInstance(Context context) {
        if (mInstance == null) {
            mInstance = new AppSetting(context);
        }
        return mInstance;
    }
}
```

**（2）静态变量导致内存泄漏**
静态变量存储在方法区，它的生命周期从类加载开始，到整个进程结束。一旦静态变量初始化后，它所持有的引用只有等到进程结束才会释放。

```java
public class MainActivity extends AppCompatActivity {
    private static Info sInfo;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        sInfo = new Info(this);
    }
}

class Info {
    Activity mActivity;

    public Info(Activity activity) {
        mActivity = activity;
    }
}
```

分析：
Info作为Activity的静态成员，并且持有Activity的引用，但是sInfo作为静态变量，生命周期肯定比Activity长。所以当Activity退出后，sInfo仍然引用了Activity，导致Activity不能被回收，引起内存泄漏。
解决：
在Activity退出时，可以在onDestory中，把静态引用变量置为null。

```java
@Override
    protected void onDestroy() {
        super.onDestroy();
        if (sInfo != null) {
            sInfo = null;
        }
    }
```

**（3）非静态内部类导致内存泄漏**
非静态内部类（包括匿名内部类）默认就会持有外部类的引用，当非静态内部类对象的生命周期比外部类对象的生命周期长时，就会导致内存泄漏。常见于Handler、Thread、AsyncTask。
例1：Handler

```java
public class MainActivity1 extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        start();
    }

    private void start() {
        Message msg = Message.obtain();
        msg.what = 1;
        mHandler.sendMessage(msg);
    }

    private Handler mHandler = new Handler() {
        @Override
        public void handleMessage(@NonNull Message msg) {
            switch (msg.what) {

            }
        }
    };
}
```

分析：
在此例中，mHandler会默认持有外部类（MainActivity1）的引用，导致MainActivity1不能被回收，引起内存泄漏。
解决：

通过弱引用解决。

```java
public class MainActivity1 extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        start();
    }

    private void start() {
        Message msg = Message.obtain();
        msg.what = 1;
        mHandler.sendMessage(msg);
    }

    private Handler mHandler = new MyHandler(this);

    private static class MyHandler extends Handler {
        private WeakReference<MainActivity1> mActivity1WeakReference;

        public MyHandler(MainActivity1 activity1) {
            mActivity1WeakReference = new WeakReference<>(activity1);
        }

        @Override
        public void handleMessage(@NonNull Message msg) {
            MainActivity1 activity1 = mActivity1WeakReference.get();
            switch (msg.what) {
                //处理逻辑
            }
        }
    }
}
```

例2：Thread

```java
public class MainActivity1 extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    //处理任务
                    SystemClock.sleep(1000L);
                }
            }
        }).start();
    }
}
```

分析：
1、内部匿名的Thread实例会长久运行，不会被系统GC回收。
2、非静态内部类会持有外部类的引用。
在此例中，即使MainActivity1退出了，但是始终有一个thread持有它的引用，导致MainActivity1不能被回收，引起内存泄漏。
解决：

1、加上static后，内部类就不会持有MainActivity1的隐式引用了。

```java
public class MainActivity1 extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        new MyThread().start();
    }

    private static class MyThread extends Thread {
        @Override
        public void run() {
            while (true) {
                //处理任务
                SystemClock.sleep(1000L);
            }
        }
    }
}
```

2、解决Thread无法回收问题

```java
public class MainActivity1 extends AppCompatActivity {
    private MyThread mMyThread;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        mMyThread = new MyThread();
        mMyThread.start();
    }

    private static class MyThread extends Thread {
        private boolean mIsRunning = false;

        @Override
        public void run() {
            mIsRunning = true;
            while (mIsRunning) {
                //处理任务
                SystemClock.sleep(1000L);
            }
        }

        public void close() {
            mIsRunning = false;
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        mMyThread.close();
    }
}
```

分析：
给Thread添加结束的标志位。当thread任务执行完成后，Java会帮我们把回收线程。因此，我们要养成为thread设置退出逻辑的习惯，保证thread可以运行结束。
注：
Java threads会一直存在，只有当线程运行完成或被杀死掉，线程才会被回收。

（4）未取消注册或回调导致内存泄漏
我们在Activity中注册广播后，如果在Activity销毁后不取消注册，那么这个广播会一直存在，同上面所说的非静态内部类一样持有Activity引用，导致内存泄漏。因此注册广播后一定要在Activity销毁后取消注册。

```java
public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        this.registerReceiver(mReceiver, new IntentFilter());
    }

    private BroadcastReceiver mReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            // 收到广播时的处理
        }
    };

    @Override
    protected void onDestroy() {
        super.onDestroy();
        this.unregisterReceiver(mReceiver);
    }
}
```

（5）资源未关闭或释放导致内存泄漏
在使用流等资源时要及时关闭，这些资源在进行读写时通常都使用了缓冲，如果不及时关闭，这些缓存对象就会一直被占用，引起内存泄漏。





# 前言

- 在`Android`中，内存泄露的现象十分常见；而内存泄露导致的后果会使得应用`Crash`
- 本文 全面介绍了**内存泄露的本质、原因 & 解决方案**，最终提供一些常见的内存泄露分析工具，希望你们会喜欢。

------

# 目录

![img](https:////upload-images.jianshu.io/upload_images/944365-d4ea339f45721e8f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

示意图

------

# 1. 简介

- 即 `ML （Memory Leak）`
- 指 程序在申请内存后，当该内存不需再使用 **但 却无法被释放 & 归还给 程序**的现象

------

# 2. 对应用程序的影响

- 容易使得应用程序发生内存溢出，即 `OOM`

> 内存溢出 简介：
>
> ![img](https:////upload-images.jianshu.io/upload_images/944365-ee9150169a743416.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)
>
> 示意图

------

# 3. 发生内存泄露的本质原因

- 具体描述

![img](https:////upload-images.jianshu.io/upload_images/944365-8ba25c2f18dfda10.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/857/format/webp)

示意图

- 特别注意
   从机制上的角度来说，由于 `Java`存在垃圾回收机制（`GC`），理应不存在内存泄露；出现内存泄露的原因仅仅是外部人为原因 = **无意识地持有对象引用，使得 持有引用者的生命周期 > 被引用者的生命周期**

------

# 4. 储备知识：Android 内存管理机制

### 4.1 简介

![img](https:////upload-images.jianshu.io/upload_images/944365-ded2ae52e844c3f2.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

示意图

下面，将针对回收 进程、对象 、变量的内存分配 & 回收进行详细讲解

### 4.2 针对进程的内存策略

#### a. 内存分配策略

由 `ActivityManagerService` 集中管理 所有进程的内存分配

#### b. 内存回收策略

- 步骤1：`Application Framework`  决定回收的进程类型
   **Android中的进程 是托管的；当进程空间紧张时，会 按进程优先级低->>高的顺序 自动回收进程**

> Android将进程分为5个优先等级，具体如下：

![img](https:////upload-images.jianshu.io/upload_images/944365-97d76f93f0fdd7f6.png?imageMogr2/auto-orient/strip|imageView2/2/w/390/format/webp)

示意图

- 步骤2：

  ```
  Linux
  ```

    内核真正回收具体进程

  1. `ActivityManagerService` 对 所有进程进行评分（评分存放在变量`adj`中）
  2. 更新评分到`Linux` 内核
  3. 由`Linux` 内核完成真正的内存回收

> 此处仅总结流程，这其中的过程复杂，有兴趣的读者可研究系统源码`ActivityManagerService.java`

### 4.3 针对对象、变量的内存策略

- `Android`的对于对象、变量的内存策略同 `Java`
- 内存管理 = 对象 / 变量的内存分配 + 内存释放

下面，将详细讲解**内存分配 & 内存释放策略**

#### a. 内存分配策略

- 对象 / 变量的内存分配 **由程序自动 负责**
- 共有3种：静态分配、栈式分配、 & 堆式分配，分别面向静态变量、局部变量  & 对象实例
- 具体介绍如下

![img](https:////upload-images.jianshu.io/upload_images/944365-91cbaceb5b1c7269.png?imageMogr2/auto-orient/strip|imageView2/2/w/1110/format/webp)

示意图

注：用1个实例讲解 内存分配



```cpp
public class Sample {    
    int s1 = 0;
    Sample mSample1 = new Sample();   
    
    // 方法中的局部变量s2、mSample2存放在 栈内存
    // 变量mSample2所指向的对象实例存放在 堆内存
      // 该实例的成员变量s1、mSample1也存放在栈中
    public void method() {        
        int s2 = 0;
        Sample mSample2 = new Sample();
    }
}
    // 变量mSample3所指向的对象实例存放在堆内存
    // 该实例的成员变量s1、mSample1也存放在堆内存中
    Sample mSample3 = new Sample();
```

#### b. 内存释放策略

- 对象 / 变量的内存释放 由`Java`垃圾回收器（`GC`） / 帧栈 负责
- 此处主要讲解对象分配（即堆式分配）的内存释放策略 = `Java`垃圾回收器（`GC`）

> 由于静态分配不需释放、栈式分配仅 通过帧栈自动出、入栈，较简单，故不详细描述

- `Java`垃圾回收器（`GC`）的内存释放 = 垃圾回收算法，主要包括：

![img](https:////upload-images.jianshu.io/upload_images/944365-73aae7d87be536d6.png?imageMogr2/auto-orient/strip|imageView2/2/w/1146/format/webp)

垃圾收集算法类型

- 具体介绍如下

![img](https:////upload-images.jianshu.io/upload_images/944365-d261ccc02cfcec12.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

总结

------

# 5. 常见的内存泄露原因 & 解决方案

- 常见引发内存泄露原因主要有：

1. 集合类
2. `Static`关键字修饰的成员变量
3. 非静态内部类 / 匿名类
4. 资源对象使用后未关闭

- 下面，我将详细介绍每个引发内存泄露的原因

### 5.1 集合类

- 内存泄露原因
   集合类 添加元素后，仍引用着 集合元素对象，导致该集合元素对象不可被回收，从而 导致内存泄漏
- 实例演示



```dart
// 通过 循环申请Object 对象 & 将申请的对象逐个放入到集合List
List<Object> objectList = new ArrayList<>();        
       for (int i = 0; i < 10; i++) {
            Object o = new Object();
            objectList.add(o);
            o = null;
        }
// 虽释放了集合元素引用的本身：o=null）
// 但集合List 仍然引用该对象，故垃圾回收器GC 依然不可回收该对象
```

- 解决方案
   集合类添加集合元素对象后，在使用后必须从集合中删除。由于一个集合中有许多元素，故最简单的方法是：清空集合对象和设置为null。



```csharp
 // 释放objectList
        objectList.clear();
        objectList=null;
```

### 5.2 Static 关键字修饰的成员变量

- 储备知识
   被 `Static` 关键字修饰的成员变量的生命周期 = 应用程序的生命周期
- 泄露原因
   若使被 `Static` 关键字修饰的成员变量 引用耗费资源过多的实例（如`Context`），则容易出现该成员变量的生命周期 > 引用实例生命周期的情况，当引用实例需结束生命周期销毁时，会因静态变量的持有而无法被回收，从而出现内存泄露
- 实例讲解



```cpp
public class ClassName {
 // 定义1个静态变量
 private static Context mContext;
 //...
// 引用的是Activity的context
 mContext = context; 

// 当Activity需销毁时，由于mContext = 静态 & 生命周期 = 应用程序的生命周期，故 Activity无法被回收，从而出现内存泄露

}
```

- 解决方案

1. 尽量避免 `Static` 成员变量引用资源耗费过多的实例（如 `Context`）

> 若需引用 `Context`，则尽量使用`Applicaiton`的`Context`

1. 使用 弱引用`（WeakReference）` 代替 强引用 持有实例

### 注：静态成员变量有个非常典型的例子 = 单例模式

- 储备知识
   单例模式 由于其**静态特性**，其生命周期的长度 = 应用程序的生命周期
- 泄露原因
   若1个对象已不需再使用 而单例对象还持有该对象的引用，那么该对象将不能被正常回收 从而 导致内存泄漏
- 实例演示



```csharp
// 创建单例时，需传入一个Context
// 若传入的是Activity的Context，此时单例 则持有该Activity的引用
// 由于单例一直持有该Activity的引用（直到整个应用生命周期结束），即使该Activity退出，该Activity的内存也不会被回收
// 特别是一些庞大的Activity，此处非常容易导致OOM

public class SingleInstanceClass {    
    private static SingleInstanceClass instance;    
    private Context mContext;    
    private SingleInstanceClass(Context context) {        
        this.mContext = context; // 传递的是Activity的context
    }  
  
    public SingleInstanceClass getInstance(Context context) {        
        if (instance == null) {
            instance = new SingleInstanceClass(context);
        }        
        return instance;
    }
}
```

- 解决方案
   单例模式应该引用生命周期等于应用生命周期的对象。

> 如上述实例，应传递`Application`的`Context`，因`Application`的生命周期 = 整个应用的生命周期



```csharp
public class SingleInstanceClass {    
    private static SingleInstanceClass instance;    
    private Context mContext;    
    private SingleInstanceClass(Context context) {        
        this.mContext = context.getApplicationContext(); // 传递的是Application 的context
    }    

    public SingleInstanceClass getInstance(Context context) {        
        if (instance == null) {
            instance = new SingleInstanceClass(context);
        }        
        return instance;
    }
}
```

# 5.3 非静态内部类 / 匿名类

- 储备知识
   非静态内部类 / 匿名类 默认持有 外部类的引用；而静态内部类则不会
- 常见情况
   3种，分别是：非静态内部类的实例  = 静态、多线程、消息传递机制（`Handler`）

### 5.3.1 非静态内部类的实例  = 静态

- 泄露原因
   若 非静态内部类所创建的实例 = 静态（其生命周期 = 应用的生命周期），会因 **非静态内部类默认持有外部类的引用** 而导致外部类无法释放，最终 造成内存泄露

> 即 外部类中 持有 非静态内部类的静态对象

- 实例演示



```java
// 背景：
// a. 在启动频繁的Activity中，为了避免重复创建相同的数据资源，会在Activity内部创建一个非静态内部类的单例
// b. 每次启动Activity时都会使用该单例的数据

public class TestActivity extends AppCompatActivity {  
    
    // 非静态内部类的实例的引用
    // 注：设置为静态  
    public static InnerClass innerClass = null; 
   
    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {        
        super.onCreate(savedInstanceState);   

        // 保证非静态内部类的实例只有1个
        if (innerClass == null)
            innerClass = new InnerClass();
    }

    // 非静态内部类的定义    
    private class InnerClass {        
        //...
    }
}

// 造成内存泄露的原因：
// a. 当TestActivity销毁时，因非静态内部类单例的引用（innerClass）的生命周期 = 应用App的生命周期、持有外部类TestActivity的引用
// b. 故 TestActivity无法被GC回收，从而导致内存泄漏
```

- 解决方案
  1. 将非静态内部类设置为：静态内部类（静态内部类默认不持有外部类的引用）
  2. 该内部类抽取出来封装成一个单例
  3. 尽量 避免 非静态内部类所创建的实例 = 静态

> 若需使用`Context`，建议使用 `Application` 的 `Context`

### 5.3.2 多线程：AsyncTask、实现Runnable接口、继承Thread类

- 储备知识
   多线程的使用方法 = 非静态内部类 / 匿名类；即 线程类 属于 非静态内部类 / 匿名类
- 泄露原因
   当 工作线程正在处理任务而外部类需销毁时， **由于 工作线程实例 持有外部类引用**，将使得外部类无法被垃圾回收器（GC）回收，从而造成 内存泄露

> 1. 多线程主要使用的是：`AsyncTask`、实现`Runnable`接口 & 继承`Thread`类
> 2. 前3者内存泄露的原理相同，此处主要以继承`Thread`类 为例说明

- 实例演示



```java
  /** 
   * 方式1：新建Thread子类（内部类）
   */  
    public class MainActivity extends AppCompatActivity {

    public static final String TAG = "carson：";
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // 通过创建的内部类 实现多线程
        new MyThread().start();

    }
    // 自定义的Thread子类
    private class MyThread extends Thread{
        @Override
        public void run() {
            try {
                Thread.sleep(5000);
                Log.d(TAG, "执行了多线程");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

 /** 
   * 方式2：匿名Thread内部类
   */ 
    public class MainActivity extends AppCompatActivity {

    public static final String TAG = "carson：";

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // 通过匿名内部类 实现多线程
        new Thread() {
            @Override
            public void run() {
                try {
                    Thread.sleep(5000);
                    Log.d(TAG, "执行了多线程");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

            }
        }.start();
    }
}


/** 
* 分析：内存泄露原因
*/ 
// 工作线程Thread类属于非静态内部类 / 匿名内部类，运行时默认持有外部类的引用
// 当工作线程运行时，若外部类MainActivity需销毁
// 由于此时工作线程类实例持有外部类的引用，将使得外部类无法被垃圾回收器（GC）回收，从而造成 内存泄露
```

- 解决方案
   从上面可看出，造成内存泄露的原因有2个关键条件：

1. 存在 ”工作线程实例 持有外部类引用“ 的引用关系
2. 工作线程实例的生命周期 > 外部类的生命周期，即工作线程仍在运行 而 外部类需销毁

**解决方案的思路 = 使得上述任1条件不成立 即可。**对应打破上述条件的解决方案如下：



```java
/** 
 * 解决方式1：静态内部类
 * 原理：静态内部类 不默认持有外部类的引用，从而使得 “工作线程实例 持有 外部类引用” 的引用关系 不复存在
 * 具体实现：将Thread的子类设置成 静态内部类
 */  
  public class MainActivity extends AppCompatActivity {

  public static final String TAG = "carson：";
  @Override
  public void onCreate(Bundle savedInstanceState) {
      super.onCreate(savedInstanceState);
      setContentView(R.layout.activity_main);

      // 通过创建的内部类 实现多线程
      new MyThread().start();

  }
  // 分析1：自定义Thread子类
  // 设置为：静态内部类
  private static class MyThread extends Thread{
      @Override
      public void run() {
          try {
              Thread.sleep(5000);
              Log.d(TAG, "执行了多线程");
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
      }
  }
}

/** 
 * 解决方案2：当外部类结束生命周期时，强制结束线程
 * 原理：使得 工作线程实例的生命周期 与 外部类的生命周期 同步
 * 具体实现：当 外部类（此处以Activity为例） 结束生命周期时（此时系统会调用onDestroy（）），强制结束线程（调用stop（））
 */ 
 @Override
  protected void onDestroy() {
      super.onDestroy();
      Thread.stop();
      // 外部类Activity生命周期结束时，强制结束线程
  }
```

### 5.3.3 消息传递机制：Handler

具体请看文章：[Android 内存泄露：详解 Handler 内存泄露的原因](https://www.jianshu.com/p/ed9e15eff47a)

### 5.4 资源对象使用后未关闭

- 泄露原因
   对于资源的使用（如 广播`BraodcastReceiver`、文件流`File`、数据库游标`Cursor`、图片资源`Bitmap`等），若在`Activity`销毁时无及时关闭 / 注销这些资源，则这些资源将不会被回收，从而造成内存泄漏
- 解决方案
   在`Activity`销毁时 及时关闭 / 注销资源



```go
// 对于 广播BraodcastReceiver：注销注册
unregisterReceiver()

// 对于 文件流File：关闭流
InputStream / OutputStream.close()

// 对于数据库游标cursor：使用后关闭游标
cursor.close（）

// 对于 图片资源Bitmap：Android分配给图片的内存只有8M，若1个Bitmap对象占内存较多，当它不再被使用时，应调用recycle()回收此对象的像素所占用的内存；最后再赋为null 
Bitmap.recycle()；
Bitmap = null;

// 对于动画（属性动画）
// 将动画设置成无限循环播放repeatCount = “infinite”后
// 在Activity退出时记得停止动画
```

### 5.5 其他使用

- 除了上述4种常见情况，还有一些日常的使用会导致内存泄露
- 主要包括：`Context`、`WebView`、`Adapter`，具体介绍如下

![img](https:////upload-images.jianshu.io/upload_images/944365-4aa5cf56f0d3f6e2.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

示意图

### 5.6 总结

下面，我将用一张图总结`Android`中内存泄露的原因 & 解决方案

![img](https:////upload-images.jianshu.io/upload_images/944365-fe3b3dce5ed610b9.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

示意图

------

# 6. 辅助分析内存泄露的工具

- 哪怕完全了解 内存泄露的原因，但难免还是会出现内存泄露的现象
- 下面将简单介绍几个主流的分析内存泄露的工具，分别是
  1. `MAT(Memory Analysis Tools)`
  2. `Heap Viewer`
  3. `Allocation Tracker`
  4. `Android Studio 的 Memory Monitor`
  5. `LeakCanary`

### 6.1 MAT(Memory Analysis Tools)

- 定义：一个`Eclipse`的 `Java Heap` 内存分析工具 ->>[下载地址](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.eclipse.org%2Fmat%2F)
- 作用：查看当前内存占用情况

> 通过分析 `Java` 进程的内存快照 `HPROF` 分析，快速计算出在内存中对象占用的大小，查看哪些对象不能被垃圾收集器回收 & 可通过视图直观地查看可能造成这种结果的对象

- 具体使用：[MAT使用攻略](https://links.jianshu.com/go?to=http%3A%2F%2Fblog.csdn.net%2Fitomge%2Farticle%2Fdetails%2F48719527)

### 6.2 Heap Viewer

- 定义：一个的 `Java Heap` 内存分析工具
- 作用：查看当前内存快照

> 可查看 分别有哪些类型的数据在堆内存总 & 各种类型数据的占比情况

- 具体使用：[Heap Viewer使用攻略](https://links.jianshu.com/go?to=http%3A%2F%2Fblog.csdn.net%2Fzhangfei2018%2Farticle%2Fdetails%2F49154479)

### 6.3 Allocation Tracker

- 简介：一个内存追踪分析工具
- 作用：追踪内存分配信息，按顺序排列
- 具体使用：[Allocation Tracker使用攻略](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.kancloud.cn%2Fdigest%2Fitfootballprefermanc%2F100908)

### 6.4 Memory Monitor

- 简介：一个 `Android Studio` 自带 的图形化检测内存工具

- 作用：跟踪系统 / 应用的内存使用情况。核心功能如下

  ![img](https:////upload-images.jianshu.io/upload_images/944365-2c16e53599c5a310.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

  示意图

- 具体使用：[Android Studio 的 Memory Monitor使用攻略](https://links.jianshu.com/go?to=http%3A%2F%2Fblog.csdn.net%2Ftrue100%2Farticle%2Fdetails%2F52604910)

### 6.5 LeakCanary

- 简介：一个`square`出品的`Android`开源库 ->>[下载地址](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fsquare%2Fleakcanary)
- 作用：检测内存泄露
- 具体使用：[https://www.liaohuqiu.net/cn/posts/leak-canary/](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.liaohuqiu.net%2Fcn%2Fposts%2Fleak-canary%2F)

------

# 7. 总结

- 本文 全面介绍了内存泄露的本质、原因 & 解决方案，希望大家在开发时尽量避免出现内存泄露





# 相关问题

## 一、概念

<font color='orange'>Q：内存溢出和内存泄漏的区别</font>



<font color='orange'>Q：内存溢出，内存抖动，内存泄漏你都碰到过吗？ 怎么解决的？如何区分这几种情况？ 怎么解决由内存泄漏而导致的内存溢出？</font>



## 二、检测

<font color='orange'>Q：内存泄漏分析，LeakCanary的原理，泄漏对象是如何找到引用链的</font>



<font color='orange'>Q：怎么检查内存泄漏</font>



<font color='orange'>Q：内存泄漏检测工具</font>



## 三、场景

<font color='orange'>Q：哪些场景会出现内存泄漏（内存泄露的种类）</font>



<font color='orange'>Q：说一下Context和内存泄露</font>



<font color='orange'>Q：为什么说Handler用成员内部类会内存泄漏?Activity不是已经到gcroot被切断了吗?还有静态context持有Activity的引用会内存泄漏,必须要持有怎么办?(及时释放</font>



<font color='orange'>Q：Handler可能会导致内存泄露，为什么。从cgRoot讲一下;怎么避免这种情况</font>



## 四、解决

<font color='orange'>Q：内存泄露以及避免措施</font>



<font color='orange'>Q：如何分析内存泄漏及如何处理</font>



<font color='orange'>Q：发现了内存泄露一般怎么解决分析，有没有碰到过系统服务内存泄露的问题？</font>



<font color='orange'>Q：哪些场景会出现内存泄漏（内存泄露的种类）</font>

（1）单例造成的内存泄漏
（2）非静态内部类创建静态实例造成的内存泄漏
（3）Handler造成的内存泄漏
（4）资源对象未关闭：File、Bitmap等
（5）线程造成的内存泄漏
（6）集合容器中的内存泄漏
（7）使用ListView时造成的内存泄漏
（8）WebView造成的泄漏

（9）Binder泄漏，在bind方法时，new Binder作为返回，导致Binder泄漏。

<font color='orange'>Q：怎么避免内存泄漏</font>



<font color='orange'>Q：处理过哪些内存泄漏</font>

Handler泄漏，使用观察者模式拿到Observer后，没有销毁。

<font color='orange'>Q：聊聊内存溢出</font>

（1）内存溢出原因：
①内存中加载的数据量过于庞大，如一次从数据库取出过多数据；
②集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；
③代码中存在死循环或循环产生过多重复的对象实体
④使用的第三方软件中的BUG；
⑤启动参数内存值设定的过小
（2）内存溢出的解决方案：
①第一步，修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)
②第二步，检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。
③第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。





什么是内存抖动，产生的本质是什么？（年轻堆与老年堆机制）

你是怎么处理crash异常的，对于不能定位行数的问题怎么解决

你是怎么对内存进行管理的？（Bitmap，对象）



# 参考

1、[面试官：内存泄漏连环问。被问懵了？来看看这部视频_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili](https://www.bilibili.com/video/BV1ck4y1r7PK?from=search&seid=8113707547361918983)
2、[内存泄露：Thread是如何造成内存泄露的 - 简书 (jianshu.com)](https://www.jianshu.com/p/f50366145b4b)

[Android性能优化：关于 内存泄露 的知识都在这里了！](https://www.jianshu.com/p/97fb764f2669)
