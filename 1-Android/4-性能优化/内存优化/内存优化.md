

# 内存优化的意义

> Android性能优化三把板斧：稳定性、内存、启动速度、包体积。这几个方向的知识其实是相互关联的网状结构，例如内存控制得好，就不容易出现OOM导致的稳定性问题。同样，经过精简的包体积，也会大大提升应用启动速度。

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c2624a52a5940df99f075592f2b5c38~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.avis#?w=634&h=515&s=59316&e=png&b=fcfcfc)

相比于C/C++，JVM很大的一个跨越是实现了内存的自动分配与回收。然而，这并不意味着作为开发者可以肆无忌惮地使用内存，作为一种有限的资源，内存再大也有耗尽的时候。我们讲“内存优化”，主要是出于稳定性、流畅度、进程存活率三个维度的考虑。

1. **稳定性**：减少OOM，提高应用稳定性
2. **流畅度**：减少卡顿，提高应用流畅度
3. **进程存活率**：减少内存占用，提高应用后台运行时的存活率

# 内存理论知识

这一部分讲解内存优化相关的理论知识，为实践环节提供理论支持。首先从`虚拟机配置`角度说明Android系统里应用可用的内存上限；然后分析在这个上限之内，应用程序内存主要分配为`哪几个部分`；最后用比较多的篇幅讲解开发中关系最紧密的`对象内存分配与回收`。

## 应用可用内存：dalvik.vm配置

现在市面上主流旗舰机型的内存已经达到了`16G`的级别，比起笔记本电脑也不遑多让，然而在极限的使用条件下，仍然会不可避免地出现卡顿。对于应用程序而言，它能够使用的最大内存是在虚拟机配置里写死的，可以通过命令`adb shell getprop dalvik.vm.heapgrowthlimit`来查看，在我的手机（vivo X Note）上是`256m`。

```bash
bash

复制代码> adb shell getprop dalvik.vm.heapgrowthlimit
256m
```

此外虚拟机配置中还有`heapstartsize`、`heapsize`等参数，它们都是定义在`/system/build.prop`文件当中的，含义说明如下：

| 参数                | 含义                                                         | vivo X Note |
| ------------------- | ------------------------------------------------------------ | ----------- |
| **heapstartsize**   | 堆分配的初始大小，影响操作系统对RAM的分配和首次使用应用的流畅性 | 8m          |
| **heapgrowthlimit** | 单个应用可用的最大内存，若超出则OOM                          | 256m        |
| **heapsize**        | 单个进程可以用最大内存，仅当声明android:largeHeap=true时生效，此时会覆盖heapgrowthlimit的值 | 512m        |

## Native虚拟内存

我们知道`Android 8.0`以后，Bitmap不再存放于Java堆内存，而是位于Native的堆内存，它的上限也就是Native虚拟内存的上限，只与CPU架构相关。Native堆内存不受JVM管控。

| CPU架构  | Native堆上限         |
| -------- | -------------------- |
| **32位** | 3G(4G减去1G内核空间) |
| **64位** | 128T                 |

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e32b9ef3957f408c93d11bee96e59f6c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.avis#?w=931&h=393&s=101355&e=png&b=fcfcfc)

## 进程内存指标：USS, PSS, RSS, VSS

`dumpsys meminfo`可以看到整个系统中不同进程所占据的内存情况，最重要的有以下4个缩写指标，它们之间的关系是：`VSS >= RSS >= PSS >= USS`。在Android系统中推荐使用PSS曲线来衡量应用的物理内存占用情况。

| 内存指标 | 英文全称              | 含义     | 等价                         |
| -------- | --------------------- | -------- | ---------------------------- |
| **USS**  | Unique Set Size       | 物理内存 | 进程独占的内存               |
| **PSS**  | Proportional Set Size | 物理内存 | PSS = USS + 按比例包含共享库 |
| **RSS**  | Resident Set Size     | 物理内存 | RSS= USS+ 包含共享库         |
| **VSS**  | Virtual Set Size      | 虚拟内存 | VSS= RSS+ 未分配实际物理内存 |

可以通过`dumpsys`命令查看以上内存信息。

```bash
bash

复制代码dumpsys meminfo <pid> // 指定pid
dumpsys meminfo --package <packagename> // 指定包名，可能存在多个进程
dumpsys meminfo // 系统中所有进程的内存占用，有排序
```

按照范围从大到小，Android系统管理内存可以分为`进程、对象、变量`三个层级。

## 进程内存分配与回收

进程内存分配和回收受到Linux内核的管控，Android将进程分为`5`个优先级，当进程空间紧张时，按照优先级从低到高的顺序进行回收。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9447909da42411693ddbe136fc9d698~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.avis#?w=390&h=328&s=22178&e=png&b=ffffff)

## 对象/变量内存分配与回收

![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8f48ba3933d41fa8541b718bda16b7c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.avis#?w=811&h=571&s=97313&e=png&b=d9eafa)

对象/变量内存分配和回收受到JVM虚拟机的管控，在JVM中，内存按区域分配如下，其中方法区、堆区是供所有线程共享的。

- **方法区**：被虚拟机加载的类信息、常量、静态变量；存活于程序运行整个周期，不回收

- **堆区**：存储Java对象实例，在线程区-Java函数栈帧会定义实例指针（or引用），指向堆内的实例；GC时判断是否回收

- 线程区

  ：每一个线程单独的区域

  - **程序计数器**：当前线程运行到的指令位置行数
  - **Java函数栈帧**：存储方法执行时的局部变量、操作数；执行结束后释放
  - **Native函数栈帧**：为Native函数服务；执行结束后释放

### Java对象生命周期

从`ClassLoader`装载`.class`文件开始，一个Java对象的生命周期包含以下阶段：

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a847e9b1e16b4d479ced40859241fd2b~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.avis#?w=898&h=1127&s=106153&e=png&b=d79e00)

### JVM内存分代

Java虚拟机采用分代策略管理堆内存中的对象，分代的目的是**优化GC性能**，将具有**不同生命周期**的对象归属于不同的年代，采取**最适合它们的内存回收方式**。

**JVM运行时内存**可以分为**堆(`Heap`)** 和**非堆(`Non-heap`)** 两大部分。堆在JVM启动时创建，是**运行时数据区域**，所有**类实例**和**数组**内存从堆分配。堆以外的内存称为非堆内存，**方法区、类结构**等数据保存在非堆内存。简单说，**堆是开发者可以触及的内存部分，非堆是JVM自留的部分**。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/302d06d6a2a948f6a49f35e81338e39b~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.avis#?w=520&h=337&s=7780&e=webp&b=f9f8f8)

从**对象分代**的角度，JVM内部将对象分为3类：

- ```
  New Generation
  ```

  ，新生代，位于堆内存，内部分为3块，其中

  ```
  Eden
  ```

  和

  ```
  Survivor
  ```

  的默认比例为8:1

  - `Eden`，新创建的对象都位于该分区，满时执行GC，并将仍存活的对象复制到`From`，GC后此区域被清空
  - `From Survivor (S1)`，GC时，将仍存活的对象复制到`To`
  - `To Survivor (S2)`，满时，将仍存活的对象复制到`Old`。GC之后会交换`From`和`To`区，从而使新的`To`（也就是老的`From`）永远是空的

- `Old Generation`，老年代，位于堆内存

- `Permanent Generation`，永生代，位于非堆内存

### GC Roots

定义：通过一系列名为`GCRoots`的对象作为起始点，从这个节点向下搜索，搜索走过的路径称为`ReferenceChain`,当一个对象到`GCRoots`没有任何`ReferenceChain`相连时，（图论：这个对象不可到达），则证明这个对象不可用。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10de6730fde14b1a964f37c35881e946~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.avis#?w=1446&h=786&s=29578&e=webp&b=fefdfd)

共有`4`类`GC Roots`:

- 方法区
  - 静态引用的对象
  - 常量引用的对象
- 线程区
  - Java函数栈帧中引用的对象
  - Native函数栈帧中JNI引用的对象

### 垃圾回收算法

| 算法          | 解释                                                         | 特点                         | 应用场景                   |
| ------------- | ------------------------------------------------------------ | ---------------------------- | -------------------------- |
| **复制**      | 将内存分为2份，使用其中一份进行存储，每次执行清除时将仍然存活的对象复制到另一半，然后清除原来的内存 | 舍弃空间，换取时间上的高效率 | 对象存活率低的场景——新生代 |
| **标记-清除** | 先扫描一遍，将不存活的对象打上标记。第二遍扫描时清理掉这些对象 | 会产生不连续的内存碎片       | 对象存活率高的场景——老年代 |
| **标记-整理** | 先扫描一遍，将不存活的对象打上标记。第二遍扫描时清理掉这些对象，并将内存向一侧聚集收拢 | 防止产生内存碎片             | 对象存活率高的场景——老年代 |

# 内存问题归类

理解了JVM内存的分配与回收原理，我们看一下在Android开发中，发生内存问题的三个表现，它们分别是`内存抖动`、`内存泄漏`与`内存溢出`。其中内存抖动与泄漏是引发内存溢出的重要因素。

## 内存抖动

### 什么是内存抖动

在一段时间内，频繁地发生内存的分配和释放，在曲线图上展现为`锯齿状`的内存使用曲线。

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6da4aaaeb98410dbd46ce09dee509a3~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.avis#?w=720&h=321&s=212665&e=png&b=2b2b2b)

### 内存抖动的原因

1. 选择了不恰当的数据类型：如使用加号`+`进行字符串拼接，正确的做法是用`StringBuilder`
2. 在循环里面创建对象：则循环执行时会频繁地创建销毁
3. 在`onDraw`中创建对象：一次绘制会多次调用`onDraw`

### 如何避免内存抖动

1. 选择恰当的数据类型（`String` -> `StringBuilder`）
2. 在循环体、`onDraw`函数外创建对象并复用，减少不合理的对象创建
3. 使用对象池进行缓存复用

## 内存泄漏

直接原因是长生命周期的对象引用了短生命周期的对象，导致短生命周期的对象无法回收。主要是指Activity的泄漏，即持有Activity的变量生命周期长于Activity的生命周期，导致Activity虽然结束但其对象并未释放，其内部的成员变量也由于被持有而无法释放。反复进入退出页面，会看到内存曲线不断上升，即使手动GC也无济于事，继续下去会导致OOM。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08b30bfcd3b44f9ba58be346703caf5c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.avis#?w=1240&h=528&s=152631&e=png&b=2c2b30)

### 常见泄漏场景

在Android开发中经常会有将Activity作为Context类型参数传递的场景，用到的时候必须谨慎，防止泄漏。

#### 1.非静态内部类

非静态内部类会持有外部类对象的引用，典型的有Handler、Runnable等。内部类在编译后，会生成一个名为`this$0`的成员变量，就是外部类实例。

##### 1.1 Handler等待运行

在使用Handler处理消息时，会构造一个`Message`对象并调用`Handler.post()`，此时`Message`对象中的`target`成员变量指向该`Handler`。由于`Message`会在`MessageQueue`中按时序处理，在处理到它之前，是无法释放Handler的。也就导致了Handler所持有的外部类（通常是Activity）发生泄漏。

要解决这个问题，需要从两点入手：

1. 使用`Handler静态内部类`（或者直接新建一个类文件），Handler通过弱引用持有Activity
2. 在`Activity.onDestroy()`中清空消息队列

##### 1.2 Runnable长时间运行

与非静态内部类相类似，通过`new Runnable() {...}`创建一个匿名内部类的对象时，也会持有外部对象的引用。如果这个Runnable在线程池中排队等待处理，同样会导致Activity无法释放。解决方法与Handler类似，由于Activity与任务队列不强相关，此处不建议清空线程池中的任务队列。

1. 创建一个实现了Runnable的静态内部类，内部通过弱引用持有Activity，使用Activity时判空

```java
java

复制代码// Runnable错误用法
private Runnable mRunnable = new Runnable() {
    @Override
    public void run() {

    }
};

// Runnable正确用法
private static class MyRunnable implements Runnable {
    WeakReference<MainActivity> reference;
    public MyRunnable(MainActivity activity){
        reference = new WeakReference<>(activity);
    }
    @Override
    public void run() {
        MainActivity activity = reference.get();
    }
}
```

#### 2.方法区持有对象引用

方法区包含类结构、常量和静态变量，是`GC Roots`之一，与整个应用的生命周期相同，由于长期存活即拿即用，比较方便，但也因此容易导致内存泄漏。

##### 2.1 静态成员变量

静态成员变量在类加载的时候就会赋值，如果其中持有Activity对象，会直接导致无法回收。

##### 2.2 单例

双重检查是单例的常规写法，其实现中也用到了静态变量，因此同样有泄漏的风险。

#### 3.资源未关闭

当Activity销毁时，资源性对象不再使用，应当关闭该对象，然后将对象置为`null`，常见的有`Bitmap`、`InputStream`、`OutputStream`等实现了`Closable`接口的类。

```java
java

复制代码// Bitmap
Bitmap bitmap = new Bitmap();
...
bitmap.recycle();
bitmap = null;

// InputStream
InputStream inp = new FileInputStream("foo.txt");
...
inp.close();
inp = null;
```

#### 4.注册对象未注销

切记需要成对调用注册-注销，如`BroadcastReceiver`、`EventBus`，否则会导致Activity一直被持有，从而发生泄漏。在开发总线类框架的时候，也要注意提供相应的注销接口。

#### 5.WebView必然泄漏

这个是Android的痼疾了，一旦创建过WebView对象，就无法回收，与`Chromium内`核实现有关，网上有建议用如下方法清空WebView资源，但据网友描述在一些机型让仍然会泄露。

```kotlin
kotlin

复制代码override fun onDestroy() {
    val parent = webView?.parent
    if (parent is ViewGroup) {
        parent.removeView(webView)
    }
    webView?.destroy()
    super.onDestroy()
}
```

既然如此，就得避免创建过多的WebView对象，或者干脆另外起一个进程用作WebView展示。

1. **构建WebView对象池**，实现复用
2. **将WebView单独开辟一个进程使用**，与主进程之间跨进程通信传递数据

#### 6.集合未清空

将对象添加进集合后，集合实例会持有该对象的引用，因此在销毁时应当将集合中对应元素移除。

```java
java

复制代码// 问题场景
// 通过 循环申请Object 对象 & 将申请的对象逐个放入到集合List
List<Object> objectList = new ArrayList<>();        
for (int i = 0; i < 10; i++) {
    Object o = new Object();
    objectList.add(o);
    o = null; // 虽释放了集合元素引用的本身，但仍然被集合持有
}

// 正确写法
objectList.clear();
objectList = null;
```

## 内存溢出

当应用在为新的数据结构申请内存时，如果当前可用内存不足以提供给新对象，就会发生内存溢出（OOM，即Out of Memory）。我们面临的大部分都是Java堆内存超限问题。

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fff6523a8ae4207962171ba0f9ca114~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.avis#?w=1512&h=713&s=225099&e=png&b=ffffff)

当发生OOM时，**并不一定是当前执行的代码发生了问题**，有可能是由于之前的不正确调用，当前已经处于一个内存异常的状态，在申请开辟新内存时导致问题爆发。

# 优化思路

这里列出一些内存优化的建议，由于在应用运行的整个生命周期里都存在内存的申请和释放，因此内存优化存在于应用开发的方方面面。

## 1.精简代码

在JVM中类的数据结构位于方法区，伴随应用的整个生命周期都不会销毁，因此应当尽量精简类的结构。

- **减少不用的类**，以及类中的成员变量
- **减少不必要的三方依赖包**
- **开启应用混淆**，精简类名方法名变量名，自动清理无用的类

## 2.内存复用

通过复用，减少频繁创建销毁对象的行为，防止产生大量离散的内存碎片。

- **资源复用**：归拢通用的字符串、颜色、度量值等，进行基础布局的复用
- **视图复用**：借助ViewHolder减少视图布局开销
- **对象复用**：建立对象池，实现复用逻辑

## 3.选用性能更高的数据结构

### 3.1 慎用SharedPreferences

读取SP时会将整个xml加载到内存里，占据几十K、上百K的内存。

### 3.2 使用SparseArray、ArrayMap代替原生的HashMap

`HashMap`最初是为JVM设计的，为了减少哈希冲突，选用了一个较大的数组作为容器来降低冲突，这是一种空间换时间的思路。在Android中提供了不同的替换结构。

- `Key`是`Int`时，选用`SparseArray`
- `Key`是其他类型时，选用`ArrayMap`

它们的思路是时间换空间，内部是两个数组，节约了`HashMap`中空置的元素位。从性能角度看，当元素数量在`1000`以下时，性能几乎与`HashMap`持平。

## 4.选用性能更高的数据类型

### 4.1 避免频繁拆箱装箱（AutoBoxing）

在自动装箱时，会创建一个新的对象，从而产生更多的内存和性能开销。`int`只占`4`字节，而`Integer`对象占据`16`字节，尤其是`HashMap`此类容器，当用`Integer`作为`Key/Value`，进行添加、删除、查找操作时，会产生大量自动装箱操作。

排查方法：通过`TraceView`查看耗时，如果发现调用了大量的`Integer.valueOf()`函数，说明存在装箱行为。

### 4.2 避免使用枚举类型，用IntDef、StringDef等注解代替

枚举的优点是提供强制的类型检查，但缺点是对于`dex`构建、运行时内存都会造成更大的消耗（相比于`Integer`、`String`）。为了满足编译期间的类型检查，可以改用`IntDef`和`StringDef`，需要引入依赖：

```bash
bash

复制代码compile 'com.android.support:support-annotations:22.0.0'
```

## 5.实现onLowMemory()、onTrimMemory()方法

它们都是在`Application、Activity、Fragment、Service、ContentProvider`中提供的，用于应用内存紧张时的通知，在发生这些回调时，应当主动清除缓存，释放次要资源。通过`Context.registerComponentCallbacks()`进行注册监听。

- **onLowMemory**：发生时，所有后台进程已经被杀死
- **onTrimMemory**：Android 4.1引入，存在多个不同级别的回调

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9eb55b3888dd4f9e8b86210ba46d4dc0~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.avis#?w=970&h=800&s=155051&e=png&b=fefefe)

## 6.声明largeHeap以增大可用内存

`在AndroidManifest.xml`中声明`android:largeHeap=true`可以将应用的可用内存扩展到dalvik.vm.heapsize。但这是一种治标不治本的方法，并不推荐使用。

## 7.建立LruCache

对于可能存在复用的对象，建立LruCache，内部由`LinkedHashMap`双向链表实现（也可以自定义双向链表）。支持`get/set/sizeOf`函数。当收到低内存警告（`onLowMemory`、`onTrimMemory`）时，清空LruCache。

LruCache的实现可以参考Glide源码。

## 8.排查内存泄漏

针对上文中提出的内存泄漏风险点，使用Memory Profiler、LeakCanary、MAT等工具，逐页面进行排查。

# 典型问题：Bitmap优化

Bitmap是内存消耗的大头，在`Android 8.0`及以上版本，Bitmap内存位于Native层，可以利用虚拟内存提升存储量，同时避免JVM堆内存耗尽。即使这样，在创建Bitmap时仍然会先占用JVM的堆空间，只不过在创建后会将其复制到Native堆进行维护。

以`ARGB_8888`格式为例，一个像素占用`4bytes`，所以整个Bitmap所占据的字节数=`长*宽*4 bytes`，假设一张图片长宽各为500px，那么它需要占用`500*500*4=1,000,000B=1MB`的内存，对于长列表而言，如果使用不当，一次就可能导致`几百MB`的内存泄漏。

因此，Bitmap优化是内存优化的重中之重，通常有以下几个思路：

1. 缩放减小宽高
2. 减少每个像素占用的内存
3. 内存复用，避免重复分配
4. 大图局部加载
5. 使用完毕后释放图片资源
6. 设置图片缓存
7. 大图监控

## 1.缩放减小宽高

图片尺寸不应大于View的尺寸，例如图片是`200*200`，而View是`100*100`的，此时应当对图片进行缩放，通过`inSampleSize`实现。

```java
java

复制代码BitmapFactory.Options options = new BitmapFactory.Options();
// 宽高都变为原来的1/2
options.inSampleSize = 2;
BitmapFactory.decodeStream(is, null, options);
```

## 2.减少每个像素占用的内存

这一条适用于那些些不需要展示高清图的场景，以及低配机器的图片显示。在`API 29`中，将Bitmap分为`6`个等级，如果图片不含透明通道，可以考虑用`RGB_565`代替`ARGB_8888`，能够节约一半的内存。

- `ALPHA_8`：不存储颜色信息，每个像素占1个字节；
- `RGB_565`：仅存储`RGB`通道，每个像素占2个字节，对`Bitmap`色彩没有高要求，可以使用该模式；
- `ARGB_4444`：已弃用，用`ARGB_8888`代替；
- `ARGB_8888`：每个像素占用4个字节，保持高质量的色彩保真度，默认使用该模式；
- `RGBA_F16`：每个像素占用8个字节，适合宽色域和`HDR`；
- `HARDWARE`：一种特殊的配置，减少了内存占用同时也加快了`Bitmap`的绘制。

## 3.内存复用，避免重复分配

通过设置`BitmapFactory.Options.inBitmap`，可以在创建新的Bitmap时尝试复用`inBitmap`的内存，在`4.4`之前需要`inBitmap`与目标Bitmap同样大小，在`4.4`之后只要`inBitmap`比目标Bitmap大即可。

## 4.大图局部加载

有些场景下需要展示巨大的一张图片，比如地铁路线图、微博长图、对高像素图片进行编辑等，如果按照原图尺寸进行加载，一张`4800万像素`的照片会占据`48M`的内存，非常可怕。

因此，在大图展示的场景下，通常采用`BitmapRegionDecoder`来实现。

```java
java

复制代码BitmapRegionDecoder decoder = BitmapRegionDecoder.newInstance(inputStream, false);
BitmapFactory.Options options = new BitmapFactory.Options();
options.inPreferredConfig = Bitmap.Config.RGB_565;
// 加载图片中央200*200的局部区域
Bitmap bitmap = decoder.decodeRegion(new Rect(width/2-100, height/2-100, width/2+100, height/2+100), options);
mImageView.setImageBitmap(bitmap);
```

## 5.使用完毕后释放图片资源

Bitmap使用完毕后应当及时释放。

### 5.1 常规释放

```java
java

复制代码Bitmap bitmap = ...
// 使用该bitmap后，进行释放
bitmap.recycle();
bitmap = null;
```

### 5.2 非常规，泄漏兜底

如果Activity、Fragment发生泄漏，会导致它们持有的View无法释放，进而使View中展示的Bitmap对象无法被系统回收。

此时，可以通过覆写`View.onDetatchedFromWindow`进行监控兜底，当View从Window中被移除，且Activity处于`destroy`状态时，延迟`2s`判断，如果2s后图片仍然没有被移除，说明发生了泄漏。此时应当主动将Bitmap释放。

![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51bbe44490104804992f62f1865d7343~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.avis#?w=694&h=1286&s=223648&e=png&b=fafafa)

## 6.设置图片缓存

可以参考Glide的四级缓存策略，我之前写过文章[《Glide源码解析》](https://juejin.cn/post/7352727612660138022)。

## 7.进行大图监控

前面说过，如果Bitmap的尺寸大于目标View的尺寸，是没有意义的，这里提供一些技术手段协助进行大图监控，我们声明一个`checkBitmapFromView`的函数，用于扫描当前Activity、Fragment的全部View，并取出Bitmap进行尺寸比较，如果发现大图case则报警。

```java
java

复制代码/**
 * 1. 遍历Activity中每个View
 * 2. 获取View加载的Bitmap
 * 3. 对比View尺寸和Bitmap尺寸
 */
fun checkBitmapFromView() {
    // 实现略
}
```

如何将这段检查的逻辑插入到代码当中？有以下几种方式。

| **方案**                              | **实现思路**                                                 | **优点**                                                     | **缺点**                                                     |
| ------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **BaseActivity**                      | 在基类的onDestroy()中检查                                    | 接入简单                                                     | 侵入性强，对全部Activity产生影响，所有Activity需要继承BaseActivity |
| **ArtHook**                           | 是针对ART虚拟机的Hook方案，通过Hook ImageView的setImageBitmap函数，在其中进行检测 | 无侵入性，一次配置全局生效；可以获取代码调用堆栈，便于定位问题 | Hook方案存在兼容性风险，需要全面覆盖测试                     |
| **ASM**                               | 在编译过程中对setImageBitmap进行插桩                         | 无侵入性                                                     | 增加编译耗时，ASM代码维护成本高                              |
| **registerActivityLifecycleCallback** | 在Application中注册                                          | 无侵入性，接入简单                                           | 暂无                                                         |

# 分析工具

## Memory Profiler

## MAT（Memory Analyzer Tool）

MAt是用来分析内存快照，分析对象引用链，从而找出导致内存泄漏根因的工具。

### MAT的使用步骤

1. 下载 [eclipse.org/mat/downloa…](https://link.juejin.cn/?target=https%3A%2F%2Feclipse.org%2Fmat%2Fdownloads.php)
2. 在Android Studio中进入Memory Profiler功能，操作应用关键页面
3. 点击GC以清理掉那些没有被泄露的对象，此时剩余的是发生泄漏的
4. 将内存快照dump到本地
5. 使用Android SDK自带的转换工具（位于`platform-tools`），将`Dalvik/ART`格式的`.hprof`文件转换为MAT能识别的`J2SE`格式，最后用MAT打开文件

```bash
bash

复制代码./hprof-conv aaa.hprof aaa-converted.hprof
```

### MAT中的术语说明

- **Dominator**：支配者，如果B引用了A，那么B是A的支配者
- **Dominator Tree**：支配者引用链
- **Shallow Heap**：当前对象自身的内存占用
- **Retained Heap**：当前对象及其成员变量加在一起的总内存占用
- **Outgoing References**：当前对象引用了哪些对象
- **Incoming References**：当前对象被哪些对象引用
- **Top Consumers**：通过饼图方式列出内存占用最多的对象

## LeakCanary

在开发环境中使用，反复进出同一页面，查看是否有泄漏通知。LeakCanary可以保存`.hprof`文件，供进一步分析。关于其原理部分主要有三个考察点：怎样监听Activity销毁时机、如何判断Activity是否被释放、如何自启动，可以参考我之前写的一篇文章[《LeakCanary源码解析》](https://juejin.cn/post/7351329921773600807)。

# 线上OOM监控：美团Probe与快手KOOM

当线上发生OOM时，我们需要立即采集现场数据，并报警给服务器进行收集。对此，不同公司都提出了各自的方案，例如美团的Probe（未开源），快手的[KOOM](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FKwaiAppTeam%2FKOOM)。这些方案主要解决了以下几个问题：

- 监控OOM：当发生OOM时触发采集上报流程
- 堆转储：即采集内存快照，`dump hprof`
- 解析快照：把对分析问题无用的数据裁剪去掉，仅保留有用的信息。进行可达性分析，生成到`GC Roots`的调用链，找出泄漏根因
- 生成报告并上传：KOOM支持在端侧生成`json`格式报告，并进行上传，将解析工作交由端侧进行，能有效减少云端的分析压力

# 面试常见提问

> Q：说说你对内存优化的理解

问题比较大，采用总-分-总方式作答。

- （总）内存管理是应用性能优化中非常重要的一环，在我以往的工作中也从事过一些内存优化的工作，业余也查阅积累了一些内存优化的知识。接下来我从重要性、问题分类、常见问题场景、优化思路几个方面讲一下我的理解
- （分）不要讲的太细，一是占用时间太多，过犹不及，容易让面试官感到啰嗦，二是会留下背答案的印象
- （总）略

> Q：开发过程中你是怎样判断有内存泄漏的

在开发过程中，我通常使用以下几种方法，对内存泄漏可能存在的场景进行快速检测和定位。

1. **内存泄漏-应用全生命周期分析**：`shell命令 + LeakCanary + MAT`，运行程序并将主要链路页面都打开一遍，完全退出程序并手动触发GC。然后使用`adb shell dumpsys meminfo <packagename> -d`打印应用当前进程信息，如果存活的View和Activity、Fragment数量不是`0`，说明它们发生了泄漏。接着借助LeakCanary查看哪些对象发生了泄漏，最后用MAT找出这些泄漏对象的引用关系，定位问题根因
2. **内存泄漏-单一页面分析**：使用Memory Profiler工具，对于目标页面，反复进出5次，在最后一次退出后手动触发GC。如果此时内存曲线没有回到进入页面之前的状态，说明发生内存泄漏。然后，将内存快照保存下来，并在Memory Profiler中查看该Activity，如果存在多个实例，说明没有被回收，即发生泄漏
3. **内存上涨-单一页面分析**：利用Memory Profiler观察进入每个页面的内存变化情况，对于上升幅度大的页面，下载进入页面前后的两个内存快照并用MAT的**对比分析**功能，找出新页面内存的分配情况，被哪些大的对象所占用





# 前言

- 在 `Android`开发中，性能优化策略十分重要
- 本文主要讲解性能优化中的**内存优化**，希望你们会喜欢

------

# 目录

![img](https:////upload-images.jianshu.io/upload_images/944365-9bf57b79564680be.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

示意图

------

# 1. 定义

优化处理 应用程序的**内存使用、空间占用**

------

# 2. 作用

避免因不正确使用内存 & 缺乏管理，从而出现 **内存泄露`（ML）`、内存溢出`（OOM）`、内存空间占用过大** 等问题，最终导致应用程序崩溃（`Crash`）

------

# 3. 储备知识：Android 内存管理机制

### 3.1 简介

![img](https:////upload-images.jianshu.io/upload_images/944365-ded2ae52e844c3f2.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

示意图

下面，将针对回收 进程、对象 、变量的内存分配 & 回收进行详细讲解

### 3.2 针对进程的内存策略

#### a. 内存分配策略

由 `ActivityManagerService` 集中管理 所有进程的内存分配

#### b. 内存回收策略

- 步骤1：`Application Framework`  决定回收的进程类型
   **Android中的进程 是托管的；当进程空间紧张时，会 按进程优先级低->>高的顺序 自动回收进程**

> Android将进程分为5个优先等级，具体如下：

![img](https:////upload-images.jianshu.io/upload_images/944365-97d76f93f0fdd7f6.png?imageMogr2/auto-orient/strip|imageView2/2/w/390/format/webp)

示意图

- 步骤2：

  ```
  Linux
  ```

    内核真正回收具体进程

  1. `ActivityManagerService` 对 所有进程进行评分（评分存放在变量`adj`中）
  2. 更新评分到`Linux` 内核
  3. 由`Linux` 内核完成真正的内存回收

> 此处仅总结流程，这其中的过程复杂，有兴趣的读者可研究系统源码`ActivityManagerService.java`

### 3.3 针对对象、变量的内存策略

- `Android`的对于对象、变量的内存策略同 `Java`
- 内存管理 = 对象 / 变量的内存分配 + 内存释放

下面，将详细讲解**内存分配 & 内存释放策略**

#### a. 内存分配策略

- 对象 / 变量的内存分配 **由程序自动 负责**
- 共有3种：静态分配、栈式分配 & 堆式分配，分别面向静态变量、局部变量  & 对象实例
- 具体介绍如下

![img](https:////upload-images.jianshu.io/upload_images/944365-91cbaceb5b1c7269.png?imageMogr2/auto-orient/strip|imageView2/2/w/1110/format/webp)

示意图

注：用1个实例讲解 内存分配



```cpp
public class Sample {    
    // 该类的实例对象的成员变量s1、mSample1 & 指向对象存放在堆内存中
    int s1 = 0;
    Sample mSample1 = new Sample();   
    
    // 方法中的局部变量s2、mSample2存放在 栈内存
    // 变量mSample2所指向的对象实例存放在 堆内存
    public void method() {        
        int s2 = 0;
        Sample mSample2 = new Sample();
    }
}
    // 变量mSample3的引用存放在栈内存中
    // 变量mSample3所指向的对象实例存放在堆内存
    // 该实例的成员变量s1、mSample1也存放在堆内存中
    Sample mSample3 = new Sample();
```

#### b. 内存释放策略

- 对象 / 变量的内存释放 由`Java`垃圾回收器（`GC`） / 帧栈 负责
- 此处主要讲解对象分配（即堆式分配）的内存释放策略 = `Java`垃圾回收器（`GC`）

> 由于静态分配不需释放、栈式分配仅 通过帧栈自动出、入栈，较简单，故不详细描述

- `Java`垃圾回收器（`GC`）的内存释放 = 垃圾回收算法，主要包括：

![img](https:////upload-images.jianshu.io/upload_images/944365-73aae7d87be536d6.png?imageMogr2/auto-orient/strip|imageView2/2/w/1146/format/webp)

垃圾收集算法类型

- 具体介绍如下

![img](https:////upload-images.jianshu.io/upload_images/944365-d261ccc02cfcec12.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

总结

------

# 4. 常见的内存问题 & 优化方案

- 常见的内存问题如下
  1. 内存泄露
  2. 内存抖动
  3. 图片`Bitmap`相关
  4. 代码质量 & 数量
  5. 日常不正确使用
- 下面，我将详细分析每项的内存问题 & 给出优化方案

### 4.1 内存泄露

- 简介
   指程序在申请内存后，当该内存不需再使用但却无法被释放或归还给程序的现象，即 Memory Leak(ml)。
- 对应用程序的影响
   容易使得应用程序发生内存溢出，即 `OOM`

> 内存溢出 简介：
>
> ![img](https:////upload-images.jianshu.io/upload_images/944365-ee9150169a743416.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)
>
> 示意图

- 发生内存泄露的本质原因

![img](https:////upload-images.jianshu.io/upload_images/944365-8ba25c2f18dfda10.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/857/format/webp)

示意图

- 常见内存泄露原因
  1. 集合类
  2. `Static`关键字修饰的成员变量
  3. 非静态内部类 / 匿名类
  4. 资源对象使用后未关闭
- 优化方案
   具体请看文章：[Android性能优化：手把手带你全面了解 内存泄露 & 解决方案](https://www.jianshu.com/p/97fb764f2669)

------

### 4.2 图片资源Bitmap相关

- 优化原因
   即 为什么要优化图片`Bitmap`资源，具体如下图：

  ![img](https:////upload-images.jianshu.io/upload_images/944365-e971c9d139a03b35.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

  示意图

  

- 优化方向
   主要 从 以下方面优化图片`Bitmap`资源的使用 & 内存管理

  ![img](https:////upload-images.jianshu.io/upload_images/944365-dc9e30c3c2e678b8.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

  示意图

  

- 具体优化方案
   下面，我将详细讲解每个优化方向的具体优化方案

> 关于更加具体的介绍，请看文章：[Android性能优化：那些关于Bitmap优化的小事](https://www.jianshu.com/p/7643c6aadb53)

![img](https:////upload-images.jianshu.io/upload_images/944365-34d13c4ab292b8db.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

示意图

------

### 4.3 内存抖动

- 简介

  ![img](https:////upload-images.jianshu.io/upload_images/944365-d2e8b2fc1f8d79de.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

  示意图

- 优化方案
   **尽量避免频繁创建大量、临时的小对象**

------

### 4.4 代码质量 & 数量

- 优化原因
   代码本身的质量（如 数据结构、数据类型等） & 数量（代码量的大小）可能会导致大量的内存问题，如占用内存大、内存利用率低等

- 优化方案
   主要从代码总量、数据结构、数据类型、 & 数据对象引用 方面优化，具体如下

  ![img](https:////upload-images.jianshu.io/upload_images/944365-0eda71feac2fea10.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

  示意图

------

### 4.5 常见使用

- 优化原因
   一些常见使用也可能引发大量的内存问题，下面我将详细介绍。
- 优化方案

![img](https:////upload-images.jianshu.io/upload_images/944365-07d6a745600c8f1e.png?imageMogr2/auto-orient/strip|imageView2/2/w/585/format/webp)

> 注：
>
> 1. 还有1个内存优化的终极方案：调大 虚拟机`Dalvik`的堆内存大小
> 2. 即 在`AndroidManifest.xml`的`application`标签中增加一个`android:largeHeap`属性（值 = `true`），从而通知虚拟机 应用程序需更大的堆内存
> 3. 但不建议 & 不鼓励该做法

### 4.6 额外小技巧

此处，还有一些内存优化的小技巧希望告诉给大家

- 技巧1：获取当前可使用的内存大小
   调用 `ActivityManager.getMemoryClass（）`方法可获取当前应用可用的内存大小（单位 = 兆）
- 技巧2：获取当前的内存使用情况
   在应用生命周期的任何阶段，调用 `onTrimMemory()`获取应用程序 当前内存使用情况（以内存级别进行识别），可根据该方法返回的**内存紧张级别参数** 来释放内存

> `Android 4.0` 后提供的一个API

![img](https:////upload-images.jianshu.io/upload_images/944365-438db7cf11e0591b.png?imageMogr2/auto-orient/strip|imageView2/2/w/970/format/webp)

示意图

- 技巧3：当视图变为隐藏状态时，则释放内存
   当用户跳转到不同的应用 & 视图不再显示时, 应释放应用视图所占的资源

> 1. 注：此时释放所占用的资源能显著的提高系统的缓存处理容量
> 2. 具体操作：实现当前`Activity`类的`onTrimMemory()`后，当用户离开视图时会得到通知；若得到返回的参数 = `TRIM_MEMORY_UI_HIDDEN` 即代表视图变为隐藏状态，则可释放视图所占用的资源.

------

# 5. 辅助内存优化的分析工具

- 哪怕完全了解 内存的原因，但难免还是会出现人为难以发现的内存问题
- 下面将简单介绍几个主流的辅助分析内存优化的工具，分别是
  1. `MAT(Memory Analysis Tools)`
  2. `Heap Viewer`
  3. `Allocation Tracker`
  4. `Android Studio 的 Memory Monitor`
  5. `LeakCanary`

### 5.1 MAT(Memory Analysis Tools)

- 定义：一个`Eclipse`的 `Java Heap` 内存分析工具 ->>[下载地址](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.eclipse.org%2Fmat%2F)
- 作用：查看当前内存占用情况

> 通过分析 `Java` 进程的内存快照 `HPROF` 分析，快速计算出在内存中对象占用的大小，查看哪些对象不能被垃圾收集器回收 & 可通过视图直观地查看可能造成这种结果的对象

- 具体使用：[MAT使用攻略](https://links.jianshu.com/go?to=http%3A%2F%2Fblog.csdn.net%2Fitomge%2Farticle%2Fdetails%2F48719527)

### 5.2 Heap Viewer

- 定义：一个的 `Java Heap` 内存分析工具
- 作用：查看当前内存快照

> 可查看 分别有哪些类型的数据在堆内存总 & 各种类型数据的占比情况

- 具体使用：[Heap Viewer使用攻略](https://links.jianshu.com/go?to=http%3A%2F%2Fblog.csdn.net%2Fzhangfei2018%2Farticle%2Fdetails%2F49154479)

### 5.3 Allocation Tracker

- 简介：一个内存追踪分析工具
- 作用：追踪内存分配信息，按顺序排列
- 具体使用：[Allocation Tracker使用攻略](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.kancloud.cn%2Fdigest%2Fitfootballprefermanc%2F100908)

### 5.4 Memory Monitor

- 简介：一个 `Android Studio` 自带 的图形化检测内存工具

- 作用：跟踪系统 / 应用的内存使用情况。核心功能如下

  ![img](https:////upload-images.jianshu.io/upload_images/944365-2c16e53599c5a310.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

  示意图

- 具体使用：[Android Studio 的 Memory Monitor使用攻略](https://links.jianshu.com/go?to=http%3A%2F%2Fblog.csdn.net%2Ftrue100%2Farticle%2Fdetails%2F52604910)

### 5.5 LeakCanary

- 简介：一个`square`出品的`Android`开源库 ->>[下载地址](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fsquare%2Fleakcanary)
- 作用：检测内存泄露
- 具体使用：[https://www.liaohuqiu.net/cn/posts/leak-canary/](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.liaohuqiu.net%2Fcn%2Fposts%2Fleak-canary%2F)

**至此，关于内存优化的所有知识讲解完毕**

------

# 6. 总结

- 本文主要讲解内存优化的相关知识，总结如下：

![img](https:////upload-images.jianshu.io/upload_images/944365-1b47002364511993.png?imageMogr2/auto-orient/strip|imageView2/2/w/940/format/webp)







# 参考

1、[【万字总结】Android 内存优化知识盘点](https://juejin.cn/post/7359896145986289699)

[Android性能优化：手把手带你全面实现内存优化](https://www.jianshu.com/p/9745a9375191)
